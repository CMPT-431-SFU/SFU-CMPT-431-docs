{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"SFU-CMPT-431-T01-intro-c/","text":"Topic 1: Introduction to C \u00b6 This topic will provide a gentle introduction to the basics of procedural programming using the C programming language. C has a long history of use in computer systems programming which involves developing software to connect the low-level computer hardware to high-level, user-facing application software. Computer systems programming usually requires careful consideration of performance and resource constraints. Examples of computer systems software include compilers, operating systems, databases, numerical libraries, and embedded controllers. C was developed in the early 1970s at Bell Laboratories by Ken Thompson, Dennis Ritchie, and many others. C was originally developed for the purposes of writing an early version of the Unix operating system. The Linux operating system which you will be using in the programming assignments was inspired by these original versions of Unix, and the Linux kernel is also written in C. C provides a nice balance between high-level abstractions for productive software development and low-level control over the hardware, and thus it remains one of the primary languages chosen by computer systems programmers. We will assume students have taken an introductory programming course in a dynamic programming language (e.g., Python, MATLAB). This means we are assuming students are familiar with basic programming constructs such as variables, literals, operators, expressions, functions, conditional statements, and iteration statements. Therefore this topic will focus more on the specifics of C syntax and a precise way of illustrating execution semantics which we will use throughout the rest of the course. We will also start by focusing more on (precisely) reading C programs than on writing C programs. Just as when learning a foreign language, one must learn how to read before one can learn how to write! 1. Statements, Syntax, Semantics, State \u00b6 At a fundamental level, any procedural program can be defined by the four S's: statements, syntax, semantics, and state. The following diagram illustrates the interaction between the four S's. Let's start with an example based on the English language. A program is a sequence of statements. For example the following might be an English language program: Put the letter in the envelope. Seal the envelope. Address the envelope. Put a stamp on the envelope. Put the envelope in the mailbox. In this context, a statement is just an English language sentence. For example, \"Put the letter in the envelope.\" is a statement. The syntax is the proper English language grammar required for forming valid sentences. For example, syntax tells us that the first word of a statement should start with a capital letter, that a verb should have proper tense, and a statement should end with an appropriate choice of punctuation. The semantics is the meaning of a sentence. For example, semantics tells us that a letter is a \"written, typed, or printed communication, especially one sent in an envelope by mail or messenger\", and the semantics also help us understand that putting a letter in an envelope makes sense. The statement \"Put the elephant in the envelope.\" would be syntactically correct but would not make much semantic sense. Finally, the state involves the memory of prior statements (i.e., the state of the world) as we read or \"execute\" these statements. To execute a statement, we use the syntax and semantics to understand how that statement changes the state of the world. The \"execution arrow\" points to the current statement we are reading or executing. So in this example, the state captures the current status of the envelope. Is the envelope sealed? Is it addressed? Does it have a stamp on it? Is it in the mailbox? Here is a quick summary of the four S's: Program : sequence of statements Statement : sentence Syntax : sentence grammar Semantics : sentence meaning State : memory of prior statements When executing a program we often want to be more precise on exactly how a program's syntax and semantics modify the state. We will use state diagrams as a way to capture a program's execution precisely. Although drawing these diagrams may initially seem overly tedious, it is critical that students master this skill early. By the end of the course we will be drawing very complicated state diagrams to precisely demonstrate our understanding of the syntax and semantics of sophisticated programming paradigms; but this is only possible if students work on mastering this skill right from the beginning of the course. The following is an example of a state diagram for executing a simple English program with five statements. Each statement includes a prefix with a line number and small set of boxes, and there is space on the right to capture the state of the program. To execute this program, we simply use the following steps: Identify which statement the execution arrow is pointing to Use the syntax and semantics to understand how this statement will change the state Update the state accordingly using the space on the right Cross off the box to the left of this statement Advance the execution arrow to point to the next statement While we have explored statements, syntax, semantics, and state in the context of an English language program, our understanding applies equally well to computer languages. In the rest of this topic, we will learn the basics about statements, syntax, semantics, and state in the C programming language. 2. Variables, Literals, Operators, Expressions \u00b6 We begin by exploring the statements, syntax, semantics, and state associated with four fundamental C concepts: variables, literals, operators, and expressions. Variable : a box (in the computer's memory) which stores a value Literal : value written exactly as it is meant to be interpreted Operator : symbol with special semantics to \"operate\" on variables and literals Expression : combination of variables, literals, and operators which evaluates to a new value 2.1. Variables \u00b6 A variable is a box in the computer's memory which stores a value. It is critical to keep the concept of a variable separate from the concept of a value. A variable is not a value. A variable stores a value. The name of a variable is called its identifier . In C, identifiers can include lowercase letters, uppercase letters, numbers, and underscores. However, identifiers cannot start with a number. Identifiers also cannot be keywords which are reserved words that have special meaning within the C programming language. These rules are part of the C syntax for identifiers. The following is a list of valid identifiers (i.e., correct syntax): 1 2 3 4 5 6 7 8 my_variable MY_VARIABLE myVariable MyVariable variable_0 variable_1 _variable __variable__ The following is a list of invalid identifiers (i.e., incorrect syntax): 1 2 0_variable variable$1 The first identifier has invalid C syntax since it starts with a number, and the second identifier has invalid C syntax since it includes the $ character. These are called syntax errors . There are many styles of identifiers. For example, snakecase favors using lowercase with underscores to separate words (i.e., my_variable ), while camelcase favors using lowercase with uppercase to separate words (i.e., myVariable , MyVariable ). Often we might favor using uppercase with underscores to indicate constant variables (i.e., MY_VARIABLE ), and we might favor using leading and training underscores to indicate special internal variables (i.e., __variable__ ). Note that the C compiler does not care about which valid identifier a programmer uses to name any given variable. So why not simply name each variable a0 , a1 , a2 , etc? While the C compiler does not care, the reader of your program definitely cares about which valid identifiers a programmer uses. Careful and consistent selection of identifiers can significantly improve the readability of your programs, which in turn makes your programs easier to debug, maintain, and extend. It is also important to note that in practical situations the programmer actually does not get to choose his or her own coding style (or coding conventions). A company or open-source project will usually have its own coding conventions that it expects its developers to follow. Similarly, in this course we have our own coding conventions that we expect students to follow. The coding conventions are located here: https://cornell-SFU-CMPT-431.github.io/ece2400-docs/ece2400-coding-conventions All variables also have a type . The type specifies the kind of values that can be stored in a variable. In dynamically typed languages (e.g., Python, MATLAB) the \"types\" of variables are not be known until run time (i.e., dynamically), while in statically typed languages (e.g., C, C++) the \"types\" of variables must be known at compile time (i.e., statically). This is an absolutely critical distinction that also has fundamental implications with respect to the tension between productivity- vs. efficiency-level languages. We will learn more about C types in Topic 3. For now, we will only use variables of type int which can store signed integer values. Signed integers include zero, negative whole numbers, and positive whole numbers. We can now introduce our very first example of a C statement. A variable declaration statement is used to create a new variable with a specific name and type. The following is a list of valid variable declaration statements: 1 2 3 4 5 6 7 8 int my_variable ; int MY_VARIABLE ; int MyVariable ; int myVariable ; int variable_0 ; int variable_1 ; int _variable ; int __variable__ ; Each statement creates a new box to hold a value of type int . As an aside, int is a keyword meaning that it cannot be used as an identifier for a variable. Note that C syntax requires all C statements to end in a semicolon. Forgetting to include the semicolon is a syntax error (meaning the C compiler cannot understand the syntax). Activity 1: Valid vs. Invalid Identifiers Which of these identifiers are valid and which are invalid? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 foo_bar 42_foo_bar 42-foo-bar _42_foo_bar FOO_BAR @FOO_BAR __FOO_BAR__ foobarbaz fooBar%Baz fooBar_BazFoo m_foo _ __ int 2.2. Literals \u00b6 A literal is a value written exactly as it is meant to be interpreted. Contrast a literal to a variable. A variable is a name for a box that can hold many different values (all of the same type!). A constant variable is a name for a box that can hold a single (constant) value. A literal is not a name; it is not a variable. A literal is literally the value itself. Some example integer literals are shown below. 1 2 3 4 42 -42 0x42 0xdeadbeef The integer literal on line 1 is literally the number 13 in base 10. The integer literal on line 2 is literally the number -42 in base 10. The integer literal on line 3 is literally the number 42 in base 16 (i.e., 66 in base 10). Finally, the integer literal on line 4 is literally a large number in base 16. Notice that C syntax specifies that by default integer literals are assumed to be base 10, but if the number includes a 0x prefix then the integer literal is in base 16 (hexadecimal). Activity 2: Hexadecimal Literals Calculate the decimal value of the following hexadecimal literals. 1 2 3 4 0x13 0x1000 0xaa 0xcafe 2.3. Operators \u00b6 An operator is a symbol with special semantics to \"operate\" on variables and literals. The very first operator we will study will be the assignment operator represented with the equal symbol ( = ). The assignment operator \"assigns\" a new value to a variable (i.e., puts a value into the variable's box). This brings us to our second example of a C statement. An assignment statement combines the assignment operator with a left-hand side (LHS) and a right-hand side (RHS). The LHS specifies the variable to change, and the RHS specifies the new value (possibly using a literal). An example of a program with two statements is shown below. 1 2 int my_variable ; my_variable = 13 ; The first line is a variable declaration statement, and the second line is an assignment statement. The semantics are that the first statement creates a box in the computer's memory, and the second statement stores the value 13 in that box. A variable declaration statement and an assignment statement can be combined into a single initialization statement . An example of the same program implemented with a single statement is shown below. 1 int my_variable = 13 ; We have now learned about three kinds of C statements: variable declaration statements, assignment statements, and initialization statements. It is important to distinguish between these three kinds of statements, especially since in C++ each of these three kinds of statements can result in quite different semantics. There are many other operators besides the assignment operator. For example, there are arithmetic operators for addition ( + ), subtraction ( - ), multiplication ( * ), division ( / ), and modulus ( % ). All of these operators can operate on integer values. We will discuss in Topic 3 subtle issues related to the fact that the computer can only represent integer values up to a specific minimum and maximum value. Note that the division operator ( / ) is for integer division meaning that 6 / 2 is 3 and 5 / 2 is 2 not 2.5. So the result of an integer division is always rounded towards zero, or in other words the fractional part is simply removed (truncated). Why does the C programming language round towards zero? Why not round to the nearest whole number? Again the C programming language is choosing efficiency; it is slightly more efficient to simply remove the fractional part vs other rounding schemes. Activity 3: Integer Division and Modulus Calculate the result of applying the following integer division and modulus operators. 1 2 3 4 5 6 7 8 9 10 11 12 15 / 2 15 / 3 15 / 4 15 / 5 -15 / 2 -15 / 3 -15 / 4 -15 / 5 15 % 2 15 % 3 15 % 4 15 % 5 2.4. Expressions \u00b6 An expression is a combination of variables, literals, and operators which evaluates to a new value. A variable's identifier is itself an expression that evaluates to the value stored in that variable. An example of an expression is shown below. 1 5 - 3 This expression evaluates to the value 2. Another example expression is shown below. 1 8 / 2 * 2 + 2 This expression can evaluate to different values depending on the order in which we apply the sequence of operators. Several options for how to evaluate this expression are shown below. 1 2 3 4 5 ((8 / 2) * 2) + 2 evaluates to 10 (8 / 2) * (2 + 2) evaluates to 16 8 / (2 * (2 + 2)) evaluates to 1 (8 / (2 * 2)) + 2 evaluates to 4 8 / ((2 * 2) + 2) evaluates to 1 Note that the final expression evaluates to 1.33 but since this is the integer division we round towards zero resulting in a value of 1. The C programming language includes semantics to unambiguously specify the correct answer based on an operator precedence table. An initial version of this table which just includes the operators we have already learned about in this topic is shown below. Category Operator Associativity Multiplicative * / % left to right Additive + - left to right Assignment = right to left Early rows have higher precedence than lower rows. So the multiplicative operators have the highest precedence and then the additive operators. The associativity column indicates the order to apply the operators when those operators are at the same precedence. So for the above example, we first consider the multiplicative operators and then move from left to right applying those operators. So we apply the division operator first, then the multiplication operator, and finally the lower precedence addition operator: 1 ((8 / 2) * 2) + 2 = 10 Note that all operators are included in the precedence table, even the assignment operator. Since the assignment operator is the last row it has the lowest precedence. This means we evaluate the LHS and RHS of the assignment operator first before doing the actual assignment. An example is shown below. 1 x = 5 - 3 We apply the subtraction operator first and so the RHS evaluates to the value 2. Then we apply the assignment operator which sets the value of variable x to be 2. Note that every expression evaluates to a value, and since x = 5 - 3 is an expression then it also evaluates to a value! The C programming language specifies that the value of applying the assignment operator is the value of the LHS. This enables complicated yet syntactically correct expressions such as: 1 y = x = 5 - 3 As before, the addition operator has the highest precedence. The precedence table specifies that the corresponding associativity is right to left. This is what the expression would look like if we inserted according to the precedence table. 1 y = (x = (5 - 3)) The expression 5 - 3 evaluates to 2, and the expression x = 2 evaluates to the value 2 (with a side-effect of updating the variable x ). In other words, this expression sets the value of both variable x and y to 2. One key take-away from this discussion is that while an expression might be syntactically correct, it doesn't mean that it is readable. We should always prefer explicitly using parenthesis to indicate the desired order of operations. Activity 4: Operator Precedence Calculate the result of evaluating the following expressions. 1 2 3 4 5 6 8 / 2 * 2 * 2 8 / (2 * (2 * 2)) 8 / 2 + 2 * 2 (8 / (2 + 2)) * 2 x = 2 x = 8 / 2 2.5. Simple C Program \u00b6 We can now compose assignment and initialization statements which use variables, literals, operators, and expressions to create our very first simple C program. Let's translate the English \"program\" we saw in Section 1 into a C program. To execute this program, we simply use the same steps we used before: Identify which statement the execution arrow is pointing to Use the syntax and semantics to understand how this statement will change the state Update the state accordingly using the space on the right Cross off the box to the left of this statement Advance the execution arrow to point to the next statement This program uses a variable declaration statement to create a variable named x (line 1), uses an assignment statement to set the value of variable x to 5 (line 2), uses another variable declaration statement to create a variable named y (line 3), uses another assignment statement to set the value of variable y to 2 (line 4), uses another variable declaration statement to create a variable named z (line 5), and finally uses another assignment statement to set the value of variable z to the value of the expression x - y (line 6). Let's look at another simple C program that illustrates an issue with uninitialized variables. Lines 1 and 2 are variable declaration statements that create boxes in our state diagram, but we do not assign a value to these boxes. These variables are called uninitialized . An uninitialized variable is not itself a problem. There is nothing syntactically or semantically wrong with lines 1 and 2. However, using an uninitialized variable does have undefined semantics. What does it mean for something to have undefined semantics? If something has undefined semantics it could: cause a compile time error message, cause a runtime error message, cause your program to crash, cause your program to hang forever, cause nothing wrong to happen, delete your hard drive, or crash your entire computer. So we should avoid doing anything which has undefined semantics. However, this begs the question, why does the C programming language even include undefined semantics? Why doesn't the C programming language specify that these uninitialized variables are automatically initialized to zero? This would certainly avoid undefined semantics and many common bugs. Recall that C is a computer systems programming language optimized for efficiency. Automatically initializing variables to zero would add a small but non-trivial overhead which could quickly have an impact on the overall performance of your programs. When faced with a choice between safety and efficiency, the C programming language will almost always choose efficiency. This is why it is an efficiency-level language! However, this also means that C programmers must be very careful in how they write their programs to avoid undefined behavior at all costs. This example also illustrates that sometimes you will need to include additional annotations to your state diagrams to explain the execution of a program. There is nothing wrong with including such additional annotations; the key is to make sure your state diagrams effectively capture your understanding of the program's execution. Let's look at one more simple C program that illustrates how values are copied between variables, and how we can assign new values to variables. Line 4 uses an assignment statement to copy the value in variable x into the variable y . It is critical to remember, that assignment copies the actual value. It does not copy any kind of high-level reference as in some dynamic programming languages (e.g., Python). Line 5 uses an assignment statement to update the value in variable x . Note that line 5 does not create a new variable named x (it is an assignment statement, not an initialization statement), and line 5 does not modify the value in variable y in any way (since variable y made a copy of the value 5). Also notice that we should never erase values in our state diagrams. Instead, you should simply cross out the old value and enter the new value. This way we can easily see how the state has changed over the execution of the program. Activity 5: State Diagram for a Simple C Program Draw a state diagram corresponding to the execution of this program. Remember to check off the execution boxes as you execute each statement. When executing line 4, recall the operator precedence table discussed in Section 2.3. 3. Blocks, Scope, Name Binding \u00b6 Blocks, scope, and name binding provide syntax and semantics to help manage more complex procedural programs. 3.1 Blocks \u00b6 A block is a compound statement, meaning it is a new kind of statement which is made up of a sequence of other statements. Blocks are indicated using curly braces. An open curly brace ( { ) is used to open a block, and a close curly brace ( } ) is used to close a block. Blocks will be critical for defining functions, conditional statements, and iteration statements. Two examples of blocks are shown below. 1 2 3 4 5 6 7 8 9 { int x = 2; int y = x; }; { int z = 3; z = z + 1; }; Since a block is itself a statement, it has a trailing semicolon. However, this semicolon is optional, and in practice it is usually omitted. 1 2 3 4 5 6 7 8 9 { int x = 2; int y = x; } { int z = 3; z = z + 1; } 3.2 Scope \u00b6 The scope of a variable is the region of code where it is accessible. Blocks create new local scopes, and variables declared within a block are only accessible from within that block. An example of a simple C program which uses a block to create a local scope is shown below. Notice that we have introduced some additional notation in our state diagram. We use an X on the right of a variable's box to indicate that this variable has gone out of scope and thus has been deallocated. Let's look at another example of using a block to create a local scope. There is an error on line 6. We cannot access the value of variable y because variable y went out of scope (i.e., was deallocated) on line 5 when the block closed. This would cause a compile time error. Blocks can be nested. Let's look at another example where we read and write variables in an outer block. The variables x and w are accessed within the inner block, even though these variables were declared in outer blocks. The change to variable w persists even after the inner block closes (i.e., changes are not \"undone\" in any way). Notice that as we open new local scopes we gradually allocate variables from top to bottom in our state diagram, and then as we close local scopes we gradually deallocate these variables from bottom to top in our state diagram. The variables are allocated and deallocated as in a stack . In a stack of cards, we place cards on top of each other, and then we draw cards from the top. In a stack of cards the stack grows up and then \"shrinks\" down. In the C stack, the stack grows down and then \"shrinks\" up. We will start calling the space on the right of our state diagrams the \"stack\". Activity 6: State Diagram for Nested Scope Draw a state diagram corresponding to the execution of this program. Remember to use an X to indicate when variables go out of scope and are thus deallocated. 3.3 Name Binding \u00b6 So far, all of our code examples have only had one variable with any given name. However, in large programs we will have to reuse the same variable name in different places. Name binding is the process of using well-defined rules to determine which variable declaration a specific variable name refers to. Note that in C, name binding happens at compile time. This means that we should be able to determine which variable declaration a specific variable name refers to based just on the code in our state diagrams (i.e., we should not need to use the runtime information in the stack). C does not allow two variables to have the same name in the same block. The following code is syntactically incorrect and will cause a compile time error: 1 2 int x = 3; int x = 3; However, C does allow two variables to have the same name in different blocks. 1 2 3 4 5 6 7 8 9 { int x = 3; int y = x; } { int x = 5; int z = x; } This makes sense, since the variable named x declared on line 2 has been deallocated by the time we reach the variable initialization statement on line 7. There is no ambiguity on which variable declaration for x is being referenced on lines 3 and 8. C also allows two variables to have the same name in nested scope. In this case, there are two variables with the name x that are in scope at the same time. The variable named x declared on line 3 is said to mask the variable named x declared on line 1. There are also two places where x is being referenced: first on line 4, and then again on line 6. The name binding rules specify which variable named x is being referenced on lines 4 and 6. The name binding rule in C is follows: start from where the variable x is being read or written work backwards out of the blocks, through open curly braces the first declaration of variable x is the one to use It is like peeling an onion. We peel off each block one at a time until we find the first declaration of the variable x . In the above example, if we start on line 4, then we would immediately find a variable named x which was declared earlier in the same block. If we start on line 6, then we don't even need to worry about the variable named x on line 3 since it has already gone out of scope. Let's look at another example with three variables named x . The access to x on line 6 corresponds to the variable declared on line 4, and the access to x on line 8 corresponds to the variable declared on line 7. Note that as with operator precedence, it is usually best if you develop your programs to avoid subtle name binding issues. Ideally, it should be obvious from reading your program which variable name refers to which variable declaration without needing to carefully consider the name binding rules. Activity 7: State Diagram for Name Binding Draw a state diagram corresponding to the execution of this program. Remember to use an X to indicate when variables go out of scope and are thus deallocated. Use the name binding rules to determine which variable named x is being referenced on line 6, and which variable named y is being referenced on lines 6 and 8. 4. Functions \u00b6 A function gives a name to a parameterized sequence of statements. A function definition describes how a function behaves. A function call is a new kind of expression to execute a function. Note that all code in C programs are inside functions! Functions are sometimes called procedures , and they are the key to procedural programming. In this section, we will discuss the syntax of a function definition before discussing the syntax and semantics of a function call. We will explore several different examples of simple C programs that use functions, and we will conclude by introducing the printf function which can be used to print values to the screen. 4.1. Function Definition \u00b6 A function definition defines the sequence of statements that make up the function. The syntax for a function definition is shown below. 1 2 3 4 rtype function_name ( ptype0 pname0 , ptype1 pname1 , ... ) { function_body ; } The function name is a unique identifier for the function. Function names must follow the same restrictions on identifiers as with variable names. The function body is the parameterized sequence of statements. The parameter list is a list of parameter types and names separated by commas (e.g., ptype0 pname0 on line 1). Finally, the return type is the type of the value returned by the function (e.g., rtype on line 1). Note that we call just line 1 the function prototype . A function prototype specifies the interface for the function (i.e., name, parameter types, and return type) without specifying the actual implementation. An example function that returns the square of an integer is shown below. 1 2 3 4 5 int square( int x ) { int y = x * x; return y; } In this example, the function name is square , the function body consists of two statements, the parameter list includes one parameter named x of type int , and the return type is also int . Line 4 is a new kind of C statement called a return statement . A return statement first evaluates the given expression and then returns the corresponding value as the result of calling the function. Let's look at another example function. 1 2 3 4 5 6 int main() { int a = 10; int b = a * a; return 0; } This function does not take any parameters. The function named main is special. It is always the first function executed in a program. The main function returns its \"value\" to the \"system\", and this value is called the exit status of the program. On Linux, returning zero means success, and returning an integer greater than zero means failure. Note that in this main function we could refactor the expression on line 4 into the square function. This might make it easier to reuse a parameterized sequence of statements in many different places. Or it might be more effective to just directly calculate the square as shown. The art of determining how to refactor code into functions is a fundamental part of procedural programming. 4.2. Function Call \u00b6 A function call is a new kind of expression with new syntax and semantics that is used to execute the parameterized sequence of statements in a function definition. The syntax for a function call is shown below. 1 function_name ( pvalue0 , pvalue1 , ... ) So to call a function we simply use its name and pass in one value for each parameter in the parameter list surrounded by parenthesis. If the parameters are themselves expressions, then we must evaluate these expressions first before calling the function. A function call is itself an expression which evaluates to the value returned by the function. Function parameters and \"local\" variables declared within a function body are effectively in a new block which is called the function's stack frame. Note that the value of each parameter is copied into these local variables. This is known as call-by-value semantics. We will learn about call-by-pointer and call-by-reference in later topics. The caller is the code which is calling the function, and the callee is the function which is being called. The precise semantics for calling a function are shown below. Evaluate parameters, allocate temporary storage in caller's stack frame if necessary Allocate storage on caller's stack frame for the return value if necessary Allocate the callee's stack frame with space allocated for parameters Copy evaluated parameters from step 1 into callee's stack frame Record location of function call Move execution arrow to first statement in callee Evaluate statements inside the callee At return statement, evaluate its argument, update appropriate variable in caller Return execution arrow back to where function was called in caller Deallocate the callee's stack frame We will use several examples to illustrate these ten steps. Our first example illustrates a basic function call for the square function discussed in the previous section. As mentioned above, the program starts its execution with the special main function. The execution of lines 7-9 is as expected. Line 10 is a variable initialization statement, which means we first must allocate space on the stack for the new variable, and then we evaluate the RHS which in this case is a function call. Let's work through all ten steps involved in the function call semantics. Step 1: There is a single parameter which is a variable name, and a variable name simply evaluates to the value stored in that variable. Step 2: Because this function call is on the RHS of a variable initialization statement, there is no need to allocate any extra space on the caller's stack frame for the return value. We can directly write the return value into b . Step 3: We allocate the callee's stack frame on the stack by drawing a nested box in the state diagram for the callee's stack frame. This box should be labeled with the name of the function. We also allocate space for each parameter. In this example, there is only one parameter so we allocate space for that parameter and label it appropriately in the state diagram. Step 4: We initialize the parameters by copying the parameter value into the appropriate box in the callee's stack frame. In this example, this involves copying the value 3 into the box for x in the square functions stack frame. Step 5: We record the location of the function call by drawing a unique number in a circle on the actual source code where the function is called and on the callee's stack frame. In this example, we label square on line 10 and the corresponding stack frame with the number 1. This information needs to be recorded in the stack so that we know where to return the execution arrow once the function call is complete. Step 6: We move the execution arrow up to the function name. We indicate this on our state diagrams by entering a dot into the execution box next to the line where the function is called (i.e., line 10). Every time we move our execution arrow backwards, we will shift marking execution boxes one column to the left. Notice how we do mark the box on lines 1 and 2. This indicates the process of setting up the stack frame and opening the local scope of the function body. Step 7: We evaluate the statements inside the callee. Notice how we allocate the local variable y on the callee's stack frame. Step 8: At the return statement on line 4, we evaluate its argument (which is just the variable name y which evaluates to the value 9), and then we update the appropriate variable in the caller. In this example, this means updating the variable b in the caller. Step 9: We move the execution arrow back to where the function was called in the caller. How do we know where the function was called? Step 5 recorded the location of the function call in the stack frame. Notice how line 5 is not executed. The return statement immediately moves the execution arrow without executing any additional statements in the function body. We will use a line every time we skip statements when moving our execution arrow forward. Step 10: Finally, we deallocate the callee's stack frame by marking an X next to all variables allocated on the callee's stack frame and by also marking an X next to the name of the function. Once we have finished with all ten steps, then we can continue executing the statement where the function was called by substituting the return value for the actual function call. Notice how at the very top of the state diagram we have labeled the entire stack as main . This indicates that everything on the stack is essentially nested within the stack frame of the top-level main function. Activity 8: State Diagram for a Simple Function Call Consider the following simple function to calculate whether or not a given parameter is odd. The function will return the value 1 if the parameter is odd and the value 0 if the parameter is even. Draw a state diagram corresponding to the execution of this program. Remember to use a dot to indicate a function call, to shift to the left one column when the execution arrow moves backwards, and to use a line to indicate skipping statements. Let's explore another example to illustrate call-by-value semantics. Notice that line 3 both reads and writes the variable named x . This is perfectly fine. Also notice that x is a parameter. Since C uses call-by-value semantics, this update to x in no way affects variables allocated on the callee's stack frame (e.g., a on the stack frame for main ). Functions are free to modify their parameters since they contain a copy of the value passed in as a parameter. Let's explore another example to illustrate name binding. Notice that this C program includes two variables named x and two variables named y . Our name binding rules can help us determine which variable declaration corresponds to which variable name. Consider the read of x on line 10. This name must correspond to the variable declared on line 9 since that is the first variable declaration we find when working backwards. Now consider the read of x on line 3. This name must correspond to the variable declared on line 1 (i.e., the parameter). The variable named y on line 3 has absolutely nothing to do with the variable named y on line 10. Finally, consider the read of x on line 4. This name must correspond to the variable declared on line 3 (i.e., a local variable in the local scope of the function body). The variable named x on line 4 has absolutely nothing to do with the variable named x on line 9. In general, we will try to avoid using the same variable names, but regardless we can always apply our name binding rules to unambiguously determine which variable declaration corresponds to which variable name. Let's explore another example to illustrate nested function calls. In this example, the square function calls the mul function to do the actual multiplication. Notice that the stack frame for the mul function is nested within the stack frame for the square function in the state diagram. We use a dot in the execution box to the left of line 16 and to the left of line 9 to indicate when each function is called. We shift marking execution boxes one column to the left each time we move our execution arrow backwards, and we use a line to indicate skipping statements when moving our execution arrow forward. We use unique numbers to mark where square and mul are called in the source code. Let's explore another example to illustrate the need for temporary storage on the stack when evaluating parameters. In this example, we use a non-trivial expression ( 2 + 1 ) as a parameter to the square function. In this situation, we need to allocate a temporary variable on the stack to hold the result of evaluating this expression. We will usually name these variables TMP on the stack. Once we have evaluated all parameters in step 1, then we can move on to step 2 in the function call semantics. In our final example, we will explore calling a function whose parameter is the result of a function call. Notice that these two function calls are not nested. Step 1 of the function call semantics tells us we must evaluate all parameters. So we first complete all ten steps for the first function call before we start the ten steps for the second function call. As with the previous example, we allocate a temporary variable on the stack ( TMP ) to hold the result of the first function call. Then we can copy the value from TMP into the parameter in step 4 of the second function call. The execution boxes clearly indicate how the execution arrow moves through the program. We use two dots to the left of line 9 to indicate the two calls to the square function. Activity 9: State Diagram for mul/odd Function Calls Consider the following program which includes two simple functions: one to calculate whether or not a given parameter is odd, and one to multiply to integers. Draw a state diagram corresponding to the execution of this program. Activity 10: State Diagram for Multiple avg Function Calls Consider the following program which calls an avg function three different times. Draw a state diagram corresponding to the execution of this program. Recall that we must allocate space on the callers stack for a temporary value when evaluating non-trivial expressions passed as parameters to a function. 4.3. The printf Function \u00b6 The printf function is provided by the C standard library and can be used to print values to the screen. The pseudo-code for the printf function definition is shown below. 1 2 3 4 5 6 7 printf ( format_string , value0 , value1 , ... ) { substitute value0 into format_string substitute value1 into format_string ... display final format_string on the screen } An example of calling printf is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <stdio.h> int square ( int x ) { int y = x * x ; return y ; } int main () { int a = 3 ; int b = square ( a ); printf ( \"square of %d is %d \\n \" , a , b ); return 0 ; } Line 1 uses the C preprocessor to import code from the standard library. Here we are importing the code in the stdio.h file which includes various functions for handling standard input from the screen and standard output to the screen. The actual call to printf is online 13. The format string includes various format specifiers as place holders for where to substitute the values. In this example we are using the %d format specifier to print an integer. Values are substituted based on their order. So the first value is substituted for the first %d , the second value is substituted for the second $d , and so on. \\n is a special escape sequence that outputs a newline (i.e., line break). We will learn more about strings in Topic 5. We will be using two online tools to enable us to quickly experiment with small C programs. The first online tool is called Compiler Explorer: https://godbolt.org You can enter simple C functions in the left text box, and then Compiler Explorer will display the corresponding machine instructions (i.e., assembly code) in the right text box. This is a great way to quickly use your browser to see the connection between C programs and the low-level computer hardware. Compiler Explorer color codes the C program and the machine instructions, so it is possible to see which C statements compile into which machine instructions. There is a drop-down menu to choose different compilers. There is also a text box where you can enter various compiler command line options. If you add the -O3 command line option you will see the optimized machine instructions, while if you remove the -O3 command line option you will see the unoptimized machine instructions. The unoptimized x86 machine instructions (i.e., without the -O3 compiler option) for our square function are shown below. 1 2 3 4 5 6 7 8 9 10 square(int): push rbp mov rbp, rsp mov DWORD PTR [rbp-20], edi mov eax, DWORD PTR [rbp-20] imul eax, DWORD PTR [rbp-20] mov DWORD PTR [rbp-4], eax mov eax, DWORD PTR [rbp-4] pop rbp ret The optimized x86 machine instructions (i.e., with the -O3 compiler option) for our square function are shown below. 1 2 3 4 square(int): imul edi, edi mov eax, edi ret Even without knowing anything about the details of each machine instruction, it is clear that the compiler has been able to significantly optimize a way unnecessary work. Modern compilers are very sophisticated so it is important to avoid premature manual optimization at the C source code level. Develop your programs so they are elegant and easy to read. Let the compiler optimize as much as it can. Then evaluate your program and only if there is an issue in terms of performance and/or space usage should you start optimizing. The second online tool is called Repl.it: https://repl.it You can use Repl.it without an account. You can always create an account later. Click new repl in the upper right-hand corner. In the Search for a language drop-down choose C and the click Create repl . You will see a default program. Click run . This will compile and execute your C program in the cloud and then display the output on the right. This is a great way to quickly experiment with C programs in your browser. The output of running the program is shown in the right text box. A link to a repl.it for our square program is show below. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-ex1 Activity 11: Write a Function to Increment by One Use Repl.it to develop a function that increments a given value by one. The function should take one parameter as shown below: 1 int increment( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity1 5. Conditional Statements \u00b6 A conditional statement enables programs to make decisions based on the values of their variables. Conditional statements enable non-linear forward control flow (i.e., the execution arrow will skip over statements). In this section, we will first discuss a new set of Boolean operators before discussing two kinds of conditional statements: if/else and switch/case statements. 5.1. Boolean Operators \u00b6 Boolean operators are used in expressions which evaluate to a \"Boolean\" value (i.e., true or false). C does not provide any built-in types for Boolean values as in many other programming languages. A \"Boolean\" value is just an integer, where we interpret a value of zero to mean false and an non-zero value to mean true. Nine Boolean operators are shown below. Operator Meaning expr1 == expr2 tests if expr1 is equal to expr2 expr1 != expr2 tests if expr1 is not equal to expr2 expr1 < expr2 tests if expr1 is less than to expr2 expr1 <= expr2 tests if expr1 is less than or equal to expr2 expr1 > expr2 tests if expr1 is greater than to expr2 expr1 >= expr2 tests if expr1 is greater than or equal to expr2 !expr computes the logical NOT of expr expr1 && expr2 computes the logical AND of expr1 and expr2 expr1 || expr2 computes the logical OR of expr1 and expr2 Using these operators in an expression evaluates to either zero (false) or one (true). As with all operators, we need to add the Boolean operators to the operator precedence table. Category Operator Associativity Unary ! right to left Multiplicative * / % left to right Additive + - left to right Relational < <= > >= left to right Equality == != left to right Logical AND && left to right Logical OR || left to right Assignment = right to left An example C program that uses Boolean operators is shown below. The Boolean expression ( x > 0 ) evaluates to either a zero or one based on whether or not x is positive or negative. Activity 12: Write a Function to Check Perfect Squares Use Repl.it to develop a function that takes two integer parameters and checks to see if one parameter is a perfect square of the other. The order should not matter. Only use arithmetic and Boolean operators. Do not use any conditional statements. The function prototype is shown below. 1 int is_perfect_square( int x, int y ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity2 5.2. if/else Conditional Statements \u00b6 if/else conditional statements are used to conditionally execute one of several statements based on one or more conditional expressions. The syntax for if/else conditional statements is shown below. 1 2 3 4 if ( conditional_expression ) then_statement ; else else_statement ; The conditional expression is an expression that returns a Boolean. The then statement is executed if the conditional expression is true. The else statement is executed if the conditional expression is false. if/else conditional statements can also include additional if else conditional expressions to create a \"chain\" of statements where exactly one is executed. 1 2 3 4 5 6 if ( conditional_expression0 ) then_statement0 ; else if ( conditional_expression1 ) then_statement1 ; else else_statement ; Either the first then statement, the second then statement, or the else statement will be executed. Since blocks are just (compound) statements, the then and/or else statements can also be a blocks in which case the syntax is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 if ( conditional_expression0 ) { then_statement0 ; then_statement1 ; } else if ( conditional_expression1 { then_statement2 ; then_statement3 ; } else { else_statement0 ; else_statement1 ; } An example C program that uses if/else conditional statements is shown below. This program includes an abs function to calculate the absolute value of the given integer parameter. In this example, the conditional expression ( x < 0 ) is on line 4. The then statement is a block that starts with the open curly brace on line 4 and ends with the close curly brace on line 6. The else statement is also a block. The execution boxes illustrate the non-linear control flow with each call to abs skipping some of the statements. Activity 13: State Diagram for Function to Check Monoticity Consider the following function that takes three integer parameters and checks to see if these values are monotonically increasing or monotonically decreasing. The function will return the value 1 if the parameters are monotonic and will return the value 0 otherwise. Draw a state diagram corresponding to the execution of this program. Activity 14: Write Function to Find Median of Three Use Repl.it to develop a function that takes three integer parameters and returns the median. The function prototype is shown below. 1 int median( int x, int y, int z ) Here is an initial Repl.it to get you started. Try to minimize the number of Boolean operators. Can you implement this function with only five Boolean operators? https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity3 5.3. switch/case Conditional Statements \u00b6 switch/case conditional statements are used to conditionally execute one or more statements based a selection expression. The syntax for switch/case conditional statements is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch ( selection_expression ) { case case_label0 : case_statement0 ; break ; case case_label1 : case_statement1 ; break ; case case_label2 : case_statement3 ; break ; default : default_statement ; } The selection expression is an expression which returns a value which is then compared against the case labels . If there is a match, then the corresponding case statements are executed. A break statement is used to jump to the end of the switch block. If no case labels match, then the default statement is executed. Note that there can be more than one case statement for a given case label without the need for a block. If we omit the break statement, then the execution \"falls through\" to the next case statement until we either execute a break statement or reach the end of the switch block An example C program that uses a switch/case conditional statement is shown below. This program includes a days_in_month function to determine how many days are in a given month. The month is specified as an integer between one and 12. In this example, the selection expression ( month ) is on line 4. There are 12 case labels. Each case statement sets the variable x appropriately, and we include a break statement after each case statement. Notice that this example includes basic error checking. If the parameter is not between one and 12, then the value of the selection express will not match any of the 12 case labels. In this situation, we execute the default statement such that the function returns -1 to indicate an error. The main function checks this return value to determine if the program should exit with an exit status of 0 to indicate success or with an exit status of 1 to indicate an error. Activity 15: State Diagram for Function to Calculate Days in Month Consider the following optimized implementation of the same days_in_month function from the previous example. This implementation uses \"fall through\" semantics. Draw a state diagram corresponding to the execution of this program. Activity 16: Write Function to Identify Small Primes Use Repl.it to develop a function that takes an integer parameter between 0 and 9 (inclusive) and returns a Boolean output. The function should return true if the input is prime (i.e., 2, 3, 5, 7) and return false if the input is not prime. Use a switch/case conditional statement to explicitly check for these prime values. The function prototype is shown below. 1 int is_prime( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity4 6. Iteration Statements \u00b6 An iteration statement enables programs to repeatedly execute a sequence of statements multiple times based on a conditional expression. Iteration statements enable backward flow control (i.e., the execution arrow will jump backwards). In this section, we will discuss two kinds of iteration statements: while loops and for loops. 6.1. while Loops \u00b6 while loops are used to repeatedly execute a sequence of statements based on a data-dependent condition that might change during the execution of these statements. The syntax for while loops is shown below. 1 2 while ( conditional_expression ) loop_body ; The conditional expression is an expression that returns a Boolean. The loop body is a statement which is executed as long as the conditional expression is true. Since blocks are just (compound) statements, the loop body can also be a block in which case the syntax is as follows. 1 2 3 while ( conditional_expression ) { loop_body ; } As an aside, an infinite loop is one in which the conditional expression is never false. Infinite loops must be avoided because they will cause your program to simply hang and never finish. Unfortunately, determining whether any given loop is an infinite loop is very difficult and indeed impossible in the general case. An example C program that uses a while loop is shown below. This program includes a div function that implements integer division through repeated subtraction. In this example, the conditional expression ( rem >= y ) is on line 5. The loop body is a block that starts with the open curly brace on line 5 and ends with the close curly brace on line 9. This example uses a temporary value ( t ) within the loop body. Notice how this variable is allocated at the beginning of the loop body and then deallocated at the end of the loop body which is why we see three different boxes named t in the state diagram. The execution boxes to the left of line 5 show that the conditional expression is executed four times. The final execution is when the conditional expression is the false and we skip over the loop body. Activity 17: State Diagram for Function to Count Digits with while Loop Consider the following program which includes a function to count the number of decimal digits in a given parameter. This function uses a while loop. Draw a state diagram corresponding to the execution of this program. Activity 18: Write Function to Output Sequence with while Loop Use Repl.it to develop a function that takes an integer parameter ( N ) and outputs a sequence according to the pattern below. The function should always return 0. N Output 0 0 1 0 _ 2 0 _ 2 3 0 _ 2 _ 4 0 _ 2 _ 4 5 0 _ 2 _ 4 _ 6 0 _ 2 _ 4 _ 5 Basically the output is a sequence of integers with the odd integers replaced with an underscore ( _ ). Use a while loop. The function prototype is shown below. 1 int print_seq( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity5 6.2. for Loops \u00b6 for loops are used to repeatedly execute a sequence of statements in a similar fashion to while loops. The key difference is that for loops are structured so as to make iterating over a range of values relatively straight-forward. The syntax for for loops is shown below. 1 2 for ( initialization_stmt ; cond_expr ; increment_stmt ; ) loop_body ; The initialization statement is executed once before the loop body executes. The conditional expression is an expression which returns a Boolean value. The loop body is a statement which is executed as long as the conditional expression is true. The increment statement is executed at the end of each iteration (i.e., after executing the loop body, but before evaluating the conditional expression). As with while loops, since blocks are just (compound) statements, the loop body can also be a block in which case the syntax is as follows. 1 2 3 for ( initialization_stmt ; cond_expr ; increment_stmt ; ) { loop_body ; } An example C program that uses a for loop is shown below. This program includes a mul function that implements integer multiplication through repeated addition. In this example, the initialization statement ( int i=0 ), the conditional expression ( i<y ), and the increment statement ( i=i+1 ) are all on line 4. The loop body is a single statement on line 5. The execution boxes to the left of line 5 show that parts of this line are executed four times. Let's step through the execution of this line in more detail. The very first time we consider line 4, we execute the initialization statement. The initialization statement is executed exactly once. Any variables declared in the initialization statement are only in scope during the execution of the loop, and they are deallocated when the loop is finished. So in this example, the variable i is only in scope (i.e., accessible) during the loop execution and it is deallocated when we reach line 6. The conditional expression is evaluated at the beginning of each loop iteration, and the increment statement is executed at the end of each loop iteration. So the very first time we consider line 4, we execute the initialization statement and then we evaluate the conditional expression, which in this case is true meaning we execute the loop body at least once. After executing the loop body we execute the increment statement, which in this case increments the variable i . We continue executing the loop body two more times. The fourth time we consider line 4, the conditional expression will be false and we skip over the loop body. So in summary, the initialization statement is executed once, the conditional expression is evaluated four times, and the increment statement is executed three times. Activity 18: State Diagram for Function to Count Digits with for Loop Consider the following program which includes a function to count the number of decimal digits in a given parameter. This function uses a for loop. Draw a state diagram corresponding to the execution of this program. Activity 19: Write Function to Output Sequence with for Loop Use Repl.it to develop a function that takes an integer parameter ( N ) and outputs a sequence according to the pattern below. The function should always return 0. N Output 0 0 1 0 _ 2 0 _ 2 3 0 _ 2 _ 4 0 _ 2 _ 4 5 0 _ 2 _ 4 _ 6 0 _ 2 _ 4 _ 5 Basically the output is a sequence of integers with the odd integers replaced with an underscore ( _ ). Use a for loop. The function prototype is shown below. 1 int print_seq( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity5 7. Syntactic Sugar \u00b6 Syntactic sugar adds new syntax but not new semantics. We can explain what a given piece of syntactic sugar means by simple showing how to transform the sugar into equivalent but previously designed syntax. Syntactic sugar simplifies certain programming patterns, but again does not introduce any fundamentally new behavior. for loops are actually just syntactic sugar for a specific common use case of while loops. The following two loops are equivalent. 1 2 3 4 5 6 7 8 9 10 11 for ( int i = 0; i < y; i = i+1 ) { z = z + x; } { int i = 0; // initialization statement while ( i < y ) { // conditional expression z = z + x; i = i + 1; // increment statement } } This equivalence should clarify some of our earlier discussion. The initialization statement on line 6 is executed exactly once before starting the execution of the loop. The conditional expression is evaluated before executing the loop body, and the increment statement is executed at the end of each iteration (before we evaluate the conditional expression for the next iteration). C provides several assignment operators that are just syntactic sugar for common programming patterns. Sugar Equivalent Syntax x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y C also provides postfix and prefix operators that are useful for incrementing and decrementing variables. Sugar Equivalent Syntax Value x++ x = x + 1 x ++x x = x + 1 x + 1 x-- x = x - 1 x --x x = x - 1 x - 1 The difference between the postfix versions ( x++ ) and the prefix versions ( ++x ) has to do with how these expressions are evaluated. The value of x++ is x , but the value of ++x is x + 1 . For example, consider the following simple program which uses a postfix operator. 1 2 int i = 1; int j = i++; After executing these two statements, the value of i will be 2 and the value of j will be 1. Now consider the following simple program which uses a prefix operator. 1 2 int i = 1; int j = ++i; After executing these two statements, the value of i will be 2 and the value of j will also be 2. C provides a compact way to write if/else statements using the ternary operator. The syntax for the ternary operator is as follows. 1 ( conditional_expression ) ? then_expression : else_expression Thus the following two functions are equivalent. 1 2 3 4 5 6 7 8 9 10 11 int min( int x, int y ) { if ( x < y ) return x; return y; } int min( int x, int y ) { return ( x < y ) ? x : y; } We have now introduce several new operators, so we need to update our operator precedence table. Category Operator Associativity Postfix a++ a-- left to right Unary ! ++a --a right to left Multiplicative * / % left to right Additive + - left to right Relational < <= > >= left to right Equality == != left to right Logical AND && left to right Logical OR || left to right Assignment = += -= *= /= a?b:c right to left","title":"Topic 1: Introduction to C"},{"location":"SFU-CMPT-431-T01-intro-c/#topic-1-introduction-to-c","text":"This topic will provide a gentle introduction to the basics of procedural programming using the C programming language. C has a long history of use in computer systems programming which involves developing software to connect the low-level computer hardware to high-level, user-facing application software. Computer systems programming usually requires careful consideration of performance and resource constraints. Examples of computer systems software include compilers, operating systems, databases, numerical libraries, and embedded controllers. C was developed in the early 1970s at Bell Laboratories by Ken Thompson, Dennis Ritchie, and many others. C was originally developed for the purposes of writing an early version of the Unix operating system. The Linux operating system which you will be using in the programming assignments was inspired by these original versions of Unix, and the Linux kernel is also written in C. C provides a nice balance between high-level abstractions for productive software development and low-level control over the hardware, and thus it remains one of the primary languages chosen by computer systems programmers. We will assume students have taken an introductory programming course in a dynamic programming language (e.g., Python, MATLAB). This means we are assuming students are familiar with basic programming constructs such as variables, literals, operators, expressions, functions, conditional statements, and iteration statements. Therefore this topic will focus more on the specifics of C syntax and a precise way of illustrating execution semantics which we will use throughout the rest of the course. We will also start by focusing more on (precisely) reading C programs than on writing C programs. Just as when learning a foreign language, one must learn how to read before one can learn how to write!","title":"Topic 1: Introduction to C"},{"location":"SFU-CMPT-431-T01-intro-c/#1-statements-syntax-semantics-state","text":"At a fundamental level, any procedural program can be defined by the four S's: statements, syntax, semantics, and state. The following diagram illustrates the interaction between the four S's. Let's start with an example based on the English language. A program is a sequence of statements. For example the following might be an English language program: Put the letter in the envelope. Seal the envelope. Address the envelope. Put a stamp on the envelope. Put the envelope in the mailbox. In this context, a statement is just an English language sentence. For example, \"Put the letter in the envelope.\" is a statement. The syntax is the proper English language grammar required for forming valid sentences. For example, syntax tells us that the first word of a statement should start with a capital letter, that a verb should have proper tense, and a statement should end with an appropriate choice of punctuation. The semantics is the meaning of a sentence. For example, semantics tells us that a letter is a \"written, typed, or printed communication, especially one sent in an envelope by mail or messenger\", and the semantics also help us understand that putting a letter in an envelope makes sense. The statement \"Put the elephant in the envelope.\" would be syntactically correct but would not make much semantic sense. Finally, the state involves the memory of prior statements (i.e., the state of the world) as we read or \"execute\" these statements. To execute a statement, we use the syntax and semantics to understand how that statement changes the state of the world. The \"execution arrow\" points to the current statement we are reading or executing. So in this example, the state captures the current status of the envelope. Is the envelope sealed? Is it addressed? Does it have a stamp on it? Is it in the mailbox? Here is a quick summary of the four S's: Program : sequence of statements Statement : sentence Syntax : sentence grammar Semantics : sentence meaning State : memory of prior statements When executing a program we often want to be more precise on exactly how a program's syntax and semantics modify the state. We will use state diagrams as a way to capture a program's execution precisely. Although drawing these diagrams may initially seem overly tedious, it is critical that students master this skill early. By the end of the course we will be drawing very complicated state diagrams to precisely demonstrate our understanding of the syntax and semantics of sophisticated programming paradigms; but this is only possible if students work on mastering this skill right from the beginning of the course. The following is an example of a state diagram for executing a simple English program with five statements. Each statement includes a prefix with a line number and small set of boxes, and there is space on the right to capture the state of the program. To execute this program, we simply use the following steps: Identify which statement the execution arrow is pointing to Use the syntax and semantics to understand how this statement will change the state Update the state accordingly using the space on the right Cross off the box to the left of this statement Advance the execution arrow to point to the next statement While we have explored statements, syntax, semantics, and state in the context of an English language program, our understanding applies equally well to computer languages. In the rest of this topic, we will learn the basics about statements, syntax, semantics, and state in the C programming language.","title":"1. Statements, Syntax, Semantics, State"},{"location":"SFU-CMPT-431-T01-intro-c/#2-variables-literals-operators-expressions","text":"We begin by exploring the statements, syntax, semantics, and state associated with four fundamental C concepts: variables, literals, operators, and expressions. Variable : a box (in the computer's memory) which stores a value Literal : value written exactly as it is meant to be interpreted Operator : symbol with special semantics to \"operate\" on variables and literals Expression : combination of variables, literals, and operators which evaluates to a new value","title":"2. Variables, Literals, Operators, Expressions"},{"location":"SFU-CMPT-431-T01-intro-c/#21-variables","text":"A variable is a box in the computer's memory which stores a value. It is critical to keep the concept of a variable separate from the concept of a value. A variable is not a value. A variable stores a value. The name of a variable is called its identifier . In C, identifiers can include lowercase letters, uppercase letters, numbers, and underscores. However, identifiers cannot start with a number. Identifiers also cannot be keywords which are reserved words that have special meaning within the C programming language. These rules are part of the C syntax for identifiers. The following is a list of valid identifiers (i.e., correct syntax): 1 2 3 4 5 6 7 8 my_variable MY_VARIABLE myVariable MyVariable variable_0 variable_1 _variable __variable__ The following is a list of invalid identifiers (i.e., incorrect syntax): 1 2 0_variable variable$1 The first identifier has invalid C syntax since it starts with a number, and the second identifier has invalid C syntax since it includes the $ character. These are called syntax errors . There are many styles of identifiers. For example, snakecase favors using lowercase with underscores to separate words (i.e., my_variable ), while camelcase favors using lowercase with uppercase to separate words (i.e., myVariable , MyVariable ). Often we might favor using uppercase with underscores to indicate constant variables (i.e., MY_VARIABLE ), and we might favor using leading and training underscores to indicate special internal variables (i.e., __variable__ ). Note that the C compiler does not care about which valid identifier a programmer uses to name any given variable. So why not simply name each variable a0 , a1 , a2 , etc? While the C compiler does not care, the reader of your program definitely cares about which valid identifiers a programmer uses. Careful and consistent selection of identifiers can significantly improve the readability of your programs, which in turn makes your programs easier to debug, maintain, and extend. It is also important to note that in practical situations the programmer actually does not get to choose his or her own coding style (or coding conventions). A company or open-source project will usually have its own coding conventions that it expects its developers to follow. Similarly, in this course we have our own coding conventions that we expect students to follow. The coding conventions are located here: https://cornell-SFU-CMPT-431.github.io/ece2400-docs/ece2400-coding-conventions All variables also have a type . The type specifies the kind of values that can be stored in a variable. In dynamically typed languages (e.g., Python, MATLAB) the \"types\" of variables are not be known until run time (i.e., dynamically), while in statically typed languages (e.g., C, C++) the \"types\" of variables must be known at compile time (i.e., statically). This is an absolutely critical distinction that also has fundamental implications with respect to the tension between productivity- vs. efficiency-level languages. We will learn more about C types in Topic 3. For now, we will only use variables of type int which can store signed integer values. Signed integers include zero, negative whole numbers, and positive whole numbers. We can now introduce our very first example of a C statement. A variable declaration statement is used to create a new variable with a specific name and type. The following is a list of valid variable declaration statements: 1 2 3 4 5 6 7 8 int my_variable ; int MY_VARIABLE ; int MyVariable ; int myVariable ; int variable_0 ; int variable_1 ; int _variable ; int __variable__ ; Each statement creates a new box to hold a value of type int . As an aside, int is a keyword meaning that it cannot be used as an identifier for a variable. Note that C syntax requires all C statements to end in a semicolon. Forgetting to include the semicolon is a syntax error (meaning the C compiler cannot understand the syntax). Activity 1: Valid vs. Invalid Identifiers Which of these identifiers are valid and which are invalid? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 foo_bar 42_foo_bar 42-foo-bar _42_foo_bar FOO_BAR @FOO_BAR __FOO_BAR__ foobarbaz fooBar%Baz fooBar_BazFoo m_foo _ __ int","title":"2.1. Variables"},{"location":"SFU-CMPT-431-T01-intro-c/#22-literals","text":"A literal is a value written exactly as it is meant to be interpreted. Contrast a literal to a variable. A variable is a name for a box that can hold many different values (all of the same type!). A constant variable is a name for a box that can hold a single (constant) value. A literal is not a name; it is not a variable. A literal is literally the value itself. Some example integer literals are shown below. 1 2 3 4 42 -42 0x42 0xdeadbeef The integer literal on line 1 is literally the number 13 in base 10. The integer literal on line 2 is literally the number -42 in base 10. The integer literal on line 3 is literally the number 42 in base 16 (i.e., 66 in base 10). Finally, the integer literal on line 4 is literally a large number in base 16. Notice that C syntax specifies that by default integer literals are assumed to be base 10, but if the number includes a 0x prefix then the integer literal is in base 16 (hexadecimal). Activity 2: Hexadecimal Literals Calculate the decimal value of the following hexadecimal literals. 1 2 3 4 0x13 0x1000 0xaa 0xcafe","title":"2.2. Literals"},{"location":"SFU-CMPT-431-T01-intro-c/#23-operators","text":"An operator is a symbol with special semantics to \"operate\" on variables and literals. The very first operator we will study will be the assignment operator represented with the equal symbol ( = ). The assignment operator \"assigns\" a new value to a variable (i.e., puts a value into the variable's box). This brings us to our second example of a C statement. An assignment statement combines the assignment operator with a left-hand side (LHS) and a right-hand side (RHS). The LHS specifies the variable to change, and the RHS specifies the new value (possibly using a literal). An example of a program with two statements is shown below. 1 2 int my_variable ; my_variable = 13 ; The first line is a variable declaration statement, and the second line is an assignment statement. The semantics are that the first statement creates a box in the computer's memory, and the second statement stores the value 13 in that box. A variable declaration statement and an assignment statement can be combined into a single initialization statement . An example of the same program implemented with a single statement is shown below. 1 int my_variable = 13 ; We have now learned about three kinds of C statements: variable declaration statements, assignment statements, and initialization statements. It is important to distinguish between these three kinds of statements, especially since in C++ each of these three kinds of statements can result in quite different semantics. There are many other operators besides the assignment operator. For example, there are arithmetic operators for addition ( + ), subtraction ( - ), multiplication ( * ), division ( / ), and modulus ( % ). All of these operators can operate on integer values. We will discuss in Topic 3 subtle issues related to the fact that the computer can only represent integer values up to a specific minimum and maximum value. Note that the division operator ( / ) is for integer division meaning that 6 / 2 is 3 and 5 / 2 is 2 not 2.5. So the result of an integer division is always rounded towards zero, or in other words the fractional part is simply removed (truncated). Why does the C programming language round towards zero? Why not round to the nearest whole number? Again the C programming language is choosing efficiency; it is slightly more efficient to simply remove the fractional part vs other rounding schemes. Activity 3: Integer Division and Modulus Calculate the result of applying the following integer division and modulus operators. 1 2 3 4 5 6 7 8 9 10 11 12 15 / 2 15 / 3 15 / 4 15 / 5 -15 / 2 -15 / 3 -15 / 4 -15 / 5 15 % 2 15 % 3 15 % 4 15 % 5","title":"2.3. Operators"},{"location":"SFU-CMPT-431-T01-intro-c/#24-expressions","text":"An expression is a combination of variables, literals, and operators which evaluates to a new value. A variable's identifier is itself an expression that evaluates to the value stored in that variable. An example of an expression is shown below. 1 5 - 3 This expression evaluates to the value 2. Another example expression is shown below. 1 8 / 2 * 2 + 2 This expression can evaluate to different values depending on the order in which we apply the sequence of operators. Several options for how to evaluate this expression are shown below. 1 2 3 4 5 ((8 / 2) * 2) + 2 evaluates to 10 (8 / 2) * (2 + 2) evaluates to 16 8 / (2 * (2 + 2)) evaluates to 1 (8 / (2 * 2)) + 2 evaluates to 4 8 / ((2 * 2) + 2) evaluates to 1 Note that the final expression evaluates to 1.33 but since this is the integer division we round towards zero resulting in a value of 1. The C programming language includes semantics to unambiguously specify the correct answer based on an operator precedence table. An initial version of this table which just includes the operators we have already learned about in this topic is shown below. Category Operator Associativity Multiplicative * / % left to right Additive + - left to right Assignment = right to left Early rows have higher precedence than lower rows. So the multiplicative operators have the highest precedence and then the additive operators. The associativity column indicates the order to apply the operators when those operators are at the same precedence. So for the above example, we first consider the multiplicative operators and then move from left to right applying those operators. So we apply the division operator first, then the multiplication operator, and finally the lower precedence addition operator: 1 ((8 / 2) * 2) + 2 = 10 Note that all operators are included in the precedence table, even the assignment operator. Since the assignment operator is the last row it has the lowest precedence. This means we evaluate the LHS and RHS of the assignment operator first before doing the actual assignment. An example is shown below. 1 x = 5 - 3 We apply the subtraction operator first and so the RHS evaluates to the value 2. Then we apply the assignment operator which sets the value of variable x to be 2. Note that every expression evaluates to a value, and since x = 5 - 3 is an expression then it also evaluates to a value! The C programming language specifies that the value of applying the assignment operator is the value of the LHS. This enables complicated yet syntactically correct expressions such as: 1 y = x = 5 - 3 As before, the addition operator has the highest precedence. The precedence table specifies that the corresponding associativity is right to left. This is what the expression would look like if we inserted according to the precedence table. 1 y = (x = (5 - 3)) The expression 5 - 3 evaluates to 2, and the expression x = 2 evaluates to the value 2 (with a side-effect of updating the variable x ). In other words, this expression sets the value of both variable x and y to 2. One key take-away from this discussion is that while an expression might be syntactically correct, it doesn't mean that it is readable. We should always prefer explicitly using parenthesis to indicate the desired order of operations. Activity 4: Operator Precedence Calculate the result of evaluating the following expressions. 1 2 3 4 5 6 8 / 2 * 2 * 2 8 / (2 * (2 * 2)) 8 / 2 + 2 * 2 (8 / (2 + 2)) * 2 x = 2 x = 8 / 2","title":"2.4. Expressions"},{"location":"SFU-CMPT-431-T01-intro-c/#25-simple-c-program","text":"We can now compose assignment and initialization statements which use variables, literals, operators, and expressions to create our very first simple C program. Let's translate the English \"program\" we saw in Section 1 into a C program. To execute this program, we simply use the same steps we used before: Identify which statement the execution arrow is pointing to Use the syntax and semantics to understand how this statement will change the state Update the state accordingly using the space on the right Cross off the box to the left of this statement Advance the execution arrow to point to the next statement This program uses a variable declaration statement to create a variable named x (line 1), uses an assignment statement to set the value of variable x to 5 (line 2), uses another variable declaration statement to create a variable named y (line 3), uses another assignment statement to set the value of variable y to 2 (line 4), uses another variable declaration statement to create a variable named z (line 5), and finally uses another assignment statement to set the value of variable z to the value of the expression x - y (line 6). Let's look at another simple C program that illustrates an issue with uninitialized variables. Lines 1 and 2 are variable declaration statements that create boxes in our state diagram, but we do not assign a value to these boxes. These variables are called uninitialized . An uninitialized variable is not itself a problem. There is nothing syntactically or semantically wrong with lines 1 and 2. However, using an uninitialized variable does have undefined semantics. What does it mean for something to have undefined semantics? If something has undefined semantics it could: cause a compile time error message, cause a runtime error message, cause your program to crash, cause your program to hang forever, cause nothing wrong to happen, delete your hard drive, or crash your entire computer. So we should avoid doing anything which has undefined semantics. However, this begs the question, why does the C programming language even include undefined semantics? Why doesn't the C programming language specify that these uninitialized variables are automatically initialized to zero? This would certainly avoid undefined semantics and many common bugs. Recall that C is a computer systems programming language optimized for efficiency. Automatically initializing variables to zero would add a small but non-trivial overhead which could quickly have an impact on the overall performance of your programs. When faced with a choice between safety and efficiency, the C programming language will almost always choose efficiency. This is why it is an efficiency-level language! However, this also means that C programmers must be very careful in how they write their programs to avoid undefined behavior at all costs. This example also illustrates that sometimes you will need to include additional annotations to your state diagrams to explain the execution of a program. There is nothing wrong with including such additional annotations; the key is to make sure your state diagrams effectively capture your understanding of the program's execution. Let's look at one more simple C program that illustrates how values are copied between variables, and how we can assign new values to variables. Line 4 uses an assignment statement to copy the value in variable x into the variable y . It is critical to remember, that assignment copies the actual value. It does not copy any kind of high-level reference as in some dynamic programming languages (e.g., Python). Line 5 uses an assignment statement to update the value in variable x . Note that line 5 does not create a new variable named x (it is an assignment statement, not an initialization statement), and line 5 does not modify the value in variable y in any way (since variable y made a copy of the value 5). Also notice that we should never erase values in our state diagrams. Instead, you should simply cross out the old value and enter the new value. This way we can easily see how the state has changed over the execution of the program. Activity 5: State Diagram for a Simple C Program Draw a state diagram corresponding to the execution of this program. Remember to check off the execution boxes as you execute each statement. When executing line 4, recall the operator precedence table discussed in Section 2.3.","title":"2.5. Simple C Program"},{"location":"SFU-CMPT-431-T01-intro-c/#3-blocks-scope-name-binding","text":"Blocks, scope, and name binding provide syntax and semantics to help manage more complex procedural programs.","title":"3. Blocks, Scope, Name Binding"},{"location":"SFU-CMPT-431-T01-intro-c/#31-blocks","text":"A block is a compound statement, meaning it is a new kind of statement which is made up of a sequence of other statements. Blocks are indicated using curly braces. An open curly brace ( { ) is used to open a block, and a close curly brace ( } ) is used to close a block. Blocks will be critical for defining functions, conditional statements, and iteration statements. Two examples of blocks are shown below. 1 2 3 4 5 6 7 8 9 { int x = 2; int y = x; }; { int z = 3; z = z + 1; }; Since a block is itself a statement, it has a trailing semicolon. However, this semicolon is optional, and in practice it is usually omitted. 1 2 3 4 5 6 7 8 9 { int x = 2; int y = x; } { int z = 3; z = z + 1; }","title":"3.1 Blocks"},{"location":"SFU-CMPT-431-T01-intro-c/#32-scope","text":"The scope of a variable is the region of code where it is accessible. Blocks create new local scopes, and variables declared within a block are only accessible from within that block. An example of a simple C program which uses a block to create a local scope is shown below. Notice that we have introduced some additional notation in our state diagram. We use an X on the right of a variable's box to indicate that this variable has gone out of scope and thus has been deallocated. Let's look at another example of using a block to create a local scope. There is an error on line 6. We cannot access the value of variable y because variable y went out of scope (i.e., was deallocated) on line 5 when the block closed. This would cause a compile time error. Blocks can be nested. Let's look at another example where we read and write variables in an outer block. The variables x and w are accessed within the inner block, even though these variables were declared in outer blocks. The change to variable w persists even after the inner block closes (i.e., changes are not \"undone\" in any way). Notice that as we open new local scopes we gradually allocate variables from top to bottom in our state diagram, and then as we close local scopes we gradually deallocate these variables from bottom to top in our state diagram. The variables are allocated and deallocated as in a stack . In a stack of cards, we place cards on top of each other, and then we draw cards from the top. In a stack of cards the stack grows up and then \"shrinks\" down. In the C stack, the stack grows down and then \"shrinks\" up. We will start calling the space on the right of our state diagrams the \"stack\". Activity 6: State Diagram for Nested Scope Draw a state diagram corresponding to the execution of this program. Remember to use an X to indicate when variables go out of scope and are thus deallocated.","title":"3.2 Scope"},{"location":"SFU-CMPT-431-T01-intro-c/#33-name-binding","text":"So far, all of our code examples have only had one variable with any given name. However, in large programs we will have to reuse the same variable name in different places. Name binding is the process of using well-defined rules to determine which variable declaration a specific variable name refers to. Note that in C, name binding happens at compile time. This means that we should be able to determine which variable declaration a specific variable name refers to based just on the code in our state diagrams (i.e., we should not need to use the runtime information in the stack). C does not allow two variables to have the same name in the same block. The following code is syntactically incorrect and will cause a compile time error: 1 2 int x = 3; int x = 3; However, C does allow two variables to have the same name in different blocks. 1 2 3 4 5 6 7 8 9 { int x = 3; int y = x; } { int x = 5; int z = x; } This makes sense, since the variable named x declared on line 2 has been deallocated by the time we reach the variable initialization statement on line 7. There is no ambiguity on which variable declaration for x is being referenced on lines 3 and 8. C also allows two variables to have the same name in nested scope. In this case, there are two variables with the name x that are in scope at the same time. The variable named x declared on line 3 is said to mask the variable named x declared on line 1. There are also two places where x is being referenced: first on line 4, and then again on line 6. The name binding rules specify which variable named x is being referenced on lines 4 and 6. The name binding rule in C is follows: start from where the variable x is being read or written work backwards out of the blocks, through open curly braces the first declaration of variable x is the one to use It is like peeling an onion. We peel off each block one at a time until we find the first declaration of the variable x . In the above example, if we start on line 4, then we would immediately find a variable named x which was declared earlier in the same block. If we start on line 6, then we don't even need to worry about the variable named x on line 3 since it has already gone out of scope. Let's look at another example with three variables named x . The access to x on line 6 corresponds to the variable declared on line 4, and the access to x on line 8 corresponds to the variable declared on line 7. Note that as with operator precedence, it is usually best if you develop your programs to avoid subtle name binding issues. Ideally, it should be obvious from reading your program which variable name refers to which variable declaration without needing to carefully consider the name binding rules. Activity 7: State Diagram for Name Binding Draw a state diagram corresponding to the execution of this program. Remember to use an X to indicate when variables go out of scope and are thus deallocated. Use the name binding rules to determine which variable named x is being referenced on line 6, and which variable named y is being referenced on lines 6 and 8.","title":"3.3 Name Binding"},{"location":"SFU-CMPT-431-T01-intro-c/#4-functions","text":"A function gives a name to a parameterized sequence of statements. A function definition describes how a function behaves. A function call is a new kind of expression to execute a function. Note that all code in C programs are inside functions! Functions are sometimes called procedures , and they are the key to procedural programming. In this section, we will discuss the syntax of a function definition before discussing the syntax and semantics of a function call. We will explore several different examples of simple C programs that use functions, and we will conclude by introducing the printf function which can be used to print values to the screen.","title":"4. Functions"},{"location":"SFU-CMPT-431-T01-intro-c/#41-function-definition","text":"A function definition defines the sequence of statements that make up the function. The syntax for a function definition is shown below. 1 2 3 4 rtype function_name ( ptype0 pname0 , ptype1 pname1 , ... ) { function_body ; } The function name is a unique identifier for the function. Function names must follow the same restrictions on identifiers as with variable names. The function body is the parameterized sequence of statements. The parameter list is a list of parameter types and names separated by commas (e.g., ptype0 pname0 on line 1). Finally, the return type is the type of the value returned by the function (e.g., rtype on line 1). Note that we call just line 1 the function prototype . A function prototype specifies the interface for the function (i.e., name, parameter types, and return type) without specifying the actual implementation. An example function that returns the square of an integer is shown below. 1 2 3 4 5 int square( int x ) { int y = x * x; return y; } In this example, the function name is square , the function body consists of two statements, the parameter list includes one parameter named x of type int , and the return type is also int . Line 4 is a new kind of C statement called a return statement . A return statement first evaluates the given expression and then returns the corresponding value as the result of calling the function. Let's look at another example function. 1 2 3 4 5 6 int main() { int a = 10; int b = a * a; return 0; } This function does not take any parameters. The function named main is special. It is always the first function executed in a program. The main function returns its \"value\" to the \"system\", and this value is called the exit status of the program. On Linux, returning zero means success, and returning an integer greater than zero means failure. Note that in this main function we could refactor the expression on line 4 into the square function. This might make it easier to reuse a parameterized sequence of statements in many different places. Or it might be more effective to just directly calculate the square as shown. The art of determining how to refactor code into functions is a fundamental part of procedural programming.","title":"4.1. Function Definition"},{"location":"SFU-CMPT-431-T01-intro-c/#42-function-call","text":"A function call is a new kind of expression with new syntax and semantics that is used to execute the parameterized sequence of statements in a function definition. The syntax for a function call is shown below. 1 function_name ( pvalue0 , pvalue1 , ... ) So to call a function we simply use its name and pass in one value for each parameter in the parameter list surrounded by parenthesis. If the parameters are themselves expressions, then we must evaluate these expressions first before calling the function. A function call is itself an expression which evaluates to the value returned by the function. Function parameters and \"local\" variables declared within a function body are effectively in a new block which is called the function's stack frame. Note that the value of each parameter is copied into these local variables. This is known as call-by-value semantics. We will learn about call-by-pointer and call-by-reference in later topics. The caller is the code which is calling the function, and the callee is the function which is being called. The precise semantics for calling a function are shown below. Evaluate parameters, allocate temporary storage in caller's stack frame if necessary Allocate storage on caller's stack frame for the return value if necessary Allocate the callee's stack frame with space allocated for parameters Copy evaluated parameters from step 1 into callee's stack frame Record location of function call Move execution arrow to first statement in callee Evaluate statements inside the callee At return statement, evaluate its argument, update appropriate variable in caller Return execution arrow back to where function was called in caller Deallocate the callee's stack frame We will use several examples to illustrate these ten steps. Our first example illustrates a basic function call for the square function discussed in the previous section. As mentioned above, the program starts its execution with the special main function. The execution of lines 7-9 is as expected. Line 10 is a variable initialization statement, which means we first must allocate space on the stack for the new variable, and then we evaluate the RHS which in this case is a function call. Let's work through all ten steps involved in the function call semantics. Step 1: There is a single parameter which is a variable name, and a variable name simply evaluates to the value stored in that variable. Step 2: Because this function call is on the RHS of a variable initialization statement, there is no need to allocate any extra space on the caller's stack frame for the return value. We can directly write the return value into b . Step 3: We allocate the callee's stack frame on the stack by drawing a nested box in the state diagram for the callee's stack frame. This box should be labeled with the name of the function. We also allocate space for each parameter. In this example, there is only one parameter so we allocate space for that parameter and label it appropriately in the state diagram. Step 4: We initialize the parameters by copying the parameter value into the appropriate box in the callee's stack frame. In this example, this involves copying the value 3 into the box for x in the square functions stack frame. Step 5: We record the location of the function call by drawing a unique number in a circle on the actual source code where the function is called and on the callee's stack frame. In this example, we label square on line 10 and the corresponding stack frame with the number 1. This information needs to be recorded in the stack so that we know where to return the execution arrow once the function call is complete. Step 6: We move the execution arrow up to the function name. We indicate this on our state diagrams by entering a dot into the execution box next to the line where the function is called (i.e., line 10). Every time we move our execution arrow backwards, we will shift marking execution boxes one column to the left. Notice how we do mark the box on lines 1 and 2. This indicates the process of setting up the stack frame and opening the local scope of the function body. Step 7: We evaluate the statements inside the callee. Notice how we allocate the local variable y on the callee's stack frame. Step 8: At the return statement on line 4, we evaluate its argument (which is just the variable name y which evaluates to the value 9), and then we update the appropriate variable in the caller. In this example, this means updating the variable b in the caller. Step 9: We move the execution arrow back to where the function was called in the caller. How do we know where the function was called? Step 5 recorded the location of the function call in the stack frame. Notice how line 5 is not executed. The return statement immediately moves the execution arrow without executing any additional statements in the function body. We will use a line every time we skip statements when moving our execution arrow forward. Step 10: Finally, we deallocate the callee's stack frame by marking an X next to all variables allocated on the callee's stack frame and by also marking an X next to the name of the function. Once we have finished with all ten steps, then we can continue executing the statement where the function was called by substituting the return value for the actual function call. Notice how at the very top of the state diagram we have labeled the entire stack as main . This indicates that everything on the stack is essentially nested within the stack frame of the top-level main function. Activity 8: State Diagram for a Simple Function Call Consider the following simple function to calculate whether or not a given parameter is odd. The function will return the value 1 if the parameter is odd and the value 0 if the parameter is even. Draw a state diagram corresponding to the execution of this program. Remember to use a dot to indicate a function call, to shift to the left one column when the execution arrow moves backwards, and to use a line to indicate skipping statements. Let's explore another example to illustrate call-by-value semantics. Notice that line 3 both reads and writes the variable named x . This is perfectly fine. Also notice that x is a parameter. Since C uses call-by-value semantics, this update to x in no way affects variables allocated on the callee's stack frame (e.g., a on the stack frame for main ). Functions are free to modify their parameters since they contain a copy of the value passed in as a parameter. Let's explore another example to illustrate name binding. Notice that this C program includes two variables named x and two variables named y . Our name binding rules can help us determine which variable declaration corresponds to which variable name. Consider the read of x on line 10. This name must correspond to the variable declared on line 9 since that is the first variable declaration we find when working backwards. Now consider the read of x on line 3. This name must correspond to the variable declared on line 1 (i.e., the parameter). The variable named y on line 3 has absolutely nothing to do with the variable named y on line 10. Finally, consider the read of x on line 4. This name must correspond to the variable declared on line 3 (i.e., a local variable in the local scope of the function body). The variable named x on line 4 has absolutely nothing to do with the variable named x on line 9. In general, we will try to avoid using the same variable names, but regardless we can always apply our name binding rules to unambiguously determine which variable declaration corresponds to which variable name. Let's explore another example to illustrate nested function calls. In this example, the square function calls the mul function to do the actual multiplication. Notice that the stack frame for the mul function is nested within the stack frame for the square function in the state diagram. We use a dot in the execution box to the left of line 16 and to the left of line 9 to indicate when each function is called. We shift marking execution boxes one column to the left each time we move our execution arrow backwards, and we use a line to indicate skipping statements when moving our execution arrow forward. We use unique numbers to mark where square and mul are called in the source code. Let's explore another example to illustrate the need for temporary storage on the stack when evaluating parameters. In this example, we use a non-trivial expression ( 2 + 1 ) as a parameter to the square function. In this situation, we need to allocate a temporary variable on the stack to hold the result of evaluating this expression. We will usually name these variables TMP on the stack. Once we have evaluated all parameters in step 1, then we can move on to step 2 in the function call semantics. In our final example, we will explore calling a function whose parameter is the result of a function call. Notice that these two function calls are not nested. Step 1 of the function call semantics tells us we must evaluate all parameters. So we first complete all ten steps for the first function call before we start the ten steps for the second function call. As with the previous example, we allocate a temporary variable on the stack ( TMP ) to hold the result of the first function call. Then we can copy the value from TMP into the parameter in step 4 of the second function call. The execution boxes clearly indicate how the execution arrow moves through the program. We use two dots to the left of line 9 to indicate the two calls to the square function. Activity 9: State Diagram for mul/odd Function Calls Consider the following program which includes two simple functions: one to calculate whether or not a given parameter is odd, and one to multiply to integers. Draw a state diagram corresponding to the execution of this program. Activity 10: State Diagram for Multiple avg Function Calls Consider the following program which calls an avg function three different times. Draw a state diagram corresponding to the execution of this program. Recall that we must allocate space on the callers stack for a temporary value when evaluating non-trivial expressions passed as parameters to a function.","title":"4.2. Function Call"},{"location":"SFU-CMPT-431-T01-intro-c/#43-the-printf-function","text":"The printf function is provided by the C standard library and can be used to print values to the screen. The pseudo-code for the printf function definition is shown below. 1 2 3 4 5 6 7 printf ( format_string , value0 , value1 , ... ) { substitute value0 into format_string substitute value1 into format_string ... display final format_string on the screen } An example of calling printf is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <stdio.h> int square ( int x ) { int y = x * x ; return y ; } int main () { int a = 3 ; int b = square ( a ); printf ( \"square of %d is %d \\n \" , a , b ); return 0 ; } Line 1 uses the C preprocessor to import code from the standard library. Here we are importing the code in the stdio.h file which includes various functions for handling standard input from the screen and standard output to the screen. The actual call to printf is online 13. The format string includes various format specifiers as place holders for where to substitute the values. In this example we are using the %d format specifier to print an integer. Values are substituted based on their order. So the first value is substituted for the first %d , the second value is substituted for the second $d , and so on. \\n is a special escape sequence that outputs a newline (i.e., line break). We will learn more about strings in Topic 5. We will be using two online tools to enable us to quickly experiment with small C programs. The first online tool is called Compiler Explorer: https://godbolt.org You can enter simple C functions in the left text box, and then Compiler Explorer will display the corresponding machine instructions (i.e., assembly code) in the right text box. This is a great way to quickly use your browser to see the connection between C programs and the low-level computer hardware. Compiler Explorer color codes the C program and the machine instructions, so it is possible to see which C statements compile into which machine instructions. There is a drop-down menu to choose different compilers. There is also a text box where you can enter various compiler command line options. If you add the -O3 command line option you will see the optimized machine instructions, while if you remove the -O3 command line option you will see the unoptimized machine instructions. The unoptimized x86 machine instructions (i.e., without the -O3 compiler option) for our square function are shown below. 1 2 3 4 5 6 7 8 9 10 square(int): push rbp mov rbp, rsp mov DWORD PTR [rbp-20], edi mov eax, DWORD PTR [rbp-20] imul eax, DWORD PTR [rbp-20] mov DWORD PTR [rbp-4], eax mov eax, DWORD PTR [rbp-4] pop rbp ret The optimized x86 machine instructions (i.e., with the -O3 compiler option) for our square function are shown below. 1 2 3 4 square(int): imul edi, edi mov eax, edi ret Even without knowing anything about the details of each machine instruction, it is clear that the compiler has been able to significantly optimize a way unnecessary work. Modern compilers are very sophisticated so it is important to avoid premature manual optimization at the C source code level. Develop your programs so they are elegant and easy to read. Let the compiler optimize as much as it can. Then evaluate your program and only if there is an issue in terms of performance and/or space usage should you start optimizing. The second online tool is called Repl.it: https://repl.it You can use Repl.it without an account. You can always create an account later. Click new repl in the upper right-hand corner. In the Search for a language drop-down choose C and the click Create repl . You will see a default program. Click run . This will compile and execute your C program in the cloud and then display the output on the right. This is a great way to quickly experiment with C programs in your browser. The output of running the program is shown in the right text box. A link to a repl.it for our square program is show below. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-ex1 Activity 11: Write a Function to Increment by One Use Repl.it to develop a function that increments a given value by one. The function should take one parameter as shown below: 1 int increment( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity1","title":"4.3. The printf Function"},{"location":"SFU-CMPT-431-T01-intro-c/#5-conditional-statements","text":"A conditional statement enables programs to make decisions based on the values of their variables. Conditional statements enable non-linear forward control flow (i.e., the execution arrow will skip over statements). In this section, we will first discuss a new set of Boolean operators before discussing two kinds of conditional statements: if/else and switch/case statements.","title":"5. Conditional Statements"},{"location":"SFU-CMPT-431-T01-intro-c/#51-boolean-operators","text":"Boolean operators are used in expressions which evaluate to a \"Boolean\" value (i.e., true or false). C does not provide any built-in types for Boolean values as in many other programming languages. A \"Boolean\" value is just an integer, where we interpret a value of zero to mean false and an non-zero value to mean true. Nine Boolean operators are shown below. Operator Meaning expr1 == expr2 tests if expr1 is equal to expr2 expr1 != expr2 tests if expr1 is not equal to expr2 expr1 < expr2 tests if expr1 is less than to expr2 expr1 <= expr2 tests if expr1 is less than or equal to expr2 expr1 > expr2 tests if expr1 is greater than to expr2 expr1 >= expr2 tests if expr1 is greater than or equal to expr2 !expr computes the logical NOT of expr expr1 && expr2 computes the logical AND of expr1 and expr2 expr1 || expr2 computes the logical OR of expr1 and expr2 Using these operators in an expression evaluates to either zero (false) or one (true). As with all operators, we need to add the Boolean operators to the operator precedence table. Category Operator Associativity Unary ! right to left Multiplicative * / % left to right Additive + - left to right Relational < <= > >= left to right Equality == != left to right Logical AND && left to right Logical OR || left to right Assignment = right to left An example C program that uses Boolean operators is shown below. The Boolean expression ( x > 0 ) evaluates to either a zero or one based on whether or not x is positive or negative. Activity 12: Write a Function to Check Perfect Squares Use Repl.it to develop a function that takes two integer parameters and checks to see if one parameter is a perfect square of the other. The order should not matter. Only use arithmetic and Boolean operators. Do not use any conditional statements. The function prototype is shown below. 1 int is_perfect_square( int x, int y ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity2","title":"5.1. Boolean Operators"},{"location":"SFU-CMPT-431-T01-intro-c/#52-ifelse-conditional-statements","text":"if/else conditional statements are used to conditionally execute one of several statements based on one or more conditional expressions. The syntax for if/else conditional statements is shown below. 1 2 3 4 if ( conditional_expression ) then_statement ; else else_statement ; The conditional expression is an expression that returns a Boolean. The then statement is executed if the conditional expression is true. The else statement is executed if the conditional expression is false. if/else conditional statements can also include additional if else conditional expressions to create a \"chain\" of statements where exactly one is executed. 1 2 3 4 5 6 if ( conditional_expression0 ) then_statement0 ; else if ( conditional_expression1 ) then_statement1 ; else else_statement ; Either the first then statement, the second then statement, or the else statement will be executed. Since blocks are just (compound) statements, the then and/or else statements can also be a blocks in which case the syntax is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 if ( conditional_expression0 ) { then_statement0 ; then_statement1 ; } else if ( conditional_expression1 { then_statement2 ; then_statement3 ; } else { else_statement0 ; else_statement1 ; } An example C program that uses if/else conditional statements is shown below. This program includes an abs function to calculate the absolute value of the given integer parameter. In this example, the conditional expression ( x < 0 ) is on line 4. The then statement is a block that starts with the open curly brace on line 4 and ends with the close curly brace on line 6. The else statement is also a block. The execution boxes illustrate the non-linear control flow with each call to abs skipping some of the statements. Activity 13: State Diagram for Function to Check Monoticity Consider the following function that takes three integer parameters and checks to see if these values are monotonically increasing or monotonically decreasing. The function will return the value 1 if the parameters are monotonic and will return the value 0 otherwise. Draw a state diagram corresponding to the execution of this program. Activity 14: Write Function to Find Median of Three Use Repl.it to develop a function that takes three integer parameters and returns the median. The function prototype is shown below. 1 int median( int x, int y, int z ) Here is an initial Repl.it to get you started. Try to minimize the number of Boolean operators. Can you implement this function with only five Boolean operators? https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity3","title":"5.2. if/else Conditional Statements"},{"location":"SFU-CMPT-431-T01-intro-c/#53-switchcase-conditional-statements","text":"switch/case conditional statements are used to conditionally execute one or more statements based a selection expression. The syntax for switch/case conditional statements is shown below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switch ( selection_expression ) { case case_label0 : case_statement0 ; break ; case case_label1 : case_statement1 ; break ; case case_label2 : case_statement3 ; break ; default : default_statement ; } The selection expression is an expression which returns a value which is then compared against the case labels . If there is a match, then the corresponding case statements are executed. A break statement is used to jump to the end of the switch block. If no case labels match, then the default statement is executed. Note that there can be more than one case statement for a given case label without the need for a block. If we omit the break statement, then the execution \"falls through\" to the next case statement until we either execute a break statement or reach the end of the switch block An example C program that uses a switch/case conditional statement is shown below. This program includes a days_in_month function to determine how many days are in a given month. The month is specified as an integer between one and 12. In this example, the selection expression ( month ) is on line 4. There are 12 case labels. Each case statement sets the variable x appropriately, and we include a break statement after each case statement. Notice that this example includes basic error checking. If the parameter is not between one and 12, then the value of the selection express will not match any of the 12 case labels. In this situation, we execute the default statement such that the function returns -1 to indicate an error. The main function checks this return value to determine if the program should exit with an exit status of 0 to indicate success or with an exit status of 1 to indicate an error. Activity 15: State Diagram for Function to Calculate Days in Month Consider the following optimized implementation of the same days_in_month function from the previous example. This implementation uses \"fall through\" semantics. Draw a state diagram corresponding to the execution of this program. Activity 16: Write Function to Identify Small Primes Use Repl.it to develop a function that takes an integer parameter between 0 and 9 (inclusive) and returns a Boolean output. The function should return true if the input is prime (i.e., 2, 3, 5, 7) and return false if the input is not prime. Use a switch/case conditional statement to explicitly check for these prime values. The function prototype is shown below. 1 int is_prime( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity4","title":"5.3. switch/case Conditional Statements"},{"location":"SFU-CMPT-431-T01-intro-c/#6-iteration-statements","text":"An iteration statement enables programs to repeatedly execute a sequence of statements multiple times based on a conditional expression. Iteration statements enable backward flow control (i.e., the execution arrow will jump backwards). In this section, we will discuss two kinds of iteration statements: while loops and for loops.","title":"6. Iteration Statements"},{"location":"SFU-CMPT-431-T01-intro-c/#61-while-loops","text":"while loops are used to repeatedly execute a sequence of statements based on a data-dependent condition that might change during the execution of these statements. The syntax for while loops is shown below. 1 2 while ( conditional_expression ) loop_body ; The conditional expression is an expression that returns a Boolean. The loop body is a statement which is executed as long as the conditional expression is true. Since blocks are just (compound) statements, the loop body can also be a block in which case the syntax is as follows. 1 2 3 while ( conditional_expression ) { loop_body ; } As an aside, an infinite loop is one in which the conditional expression is never false. Infinite loops must be avoided because they will cause your program to simply hang and never finish. Unfortunately, determining whether any given loop is an infinite loop is very difficult and indeed impossible in the general case. An example C program that uses a while loop is shown below. This program includes a div function that implements integer division through repeated subtraction. In this example, the conditional expression ( rem >= y ) is on line 5. The loop body is a block that starts with the open curly brace on line 5 and ends with the close curly brace on line 9. This example uses a temporary value ( t ) within the loop body. Notice how this variable is allocated at the beginning of the loop body and then deallocated at the end of the loop body which is why we see three different boxes named t in the state diagram. The execution boxes to the left of line 5 show that the conditional expression is executed four times. The final execution is when the conditional expression is the false and we skip over the loop body. Activity 17: State Diagram for Function to Count Digits with while Loop Consider the following program which includes a function to count the number of decimal digits in a given parameter. This function uses a while loop. Draw a state diagram corresponding to the execution of this program. Activity 18: Write Function to Output Sequence with while Loop Use Repl.it to develop a function that takes an integer parameter ( N ) and outputs a sequence according to the pattern below. The function should always return 0. N Output 0 0 1 0 _ 2 0 _ 2 3 0 _ 2 _ 4 0 _ 2 _ 4 5 0 _ 2 _ 4 _ 6 0 _ 2 _ 4 _ 5 Basically the output is a sequence of integers with the odd integers replaced with an underscore ( _ ). Use a while loop. The function prototype is shown below. 1 int print_seq( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity5","title":"6.1. while Loops"},{"location":"SFU-CMPT-431-T01-intro-c/#62-for-loops","text":"for loops are used to repeatedly execute a sequence of statements in a similar fashion to while loops. The key difference is that for loops are structured so as to make iterating over a range of values relatively straight-forward. The syntax for for loops is shown below. 1 2 for ( initialization_stmt ; cond_expr ; increment_stmt ; ) loop_body ; The initialization statement is executed once before the loop body executes. The conditional expression is an expression which returns a Boolean value. The loop body is a statement which is executed as long as the conditional expression is true. The increment statement is executed at the end of each iteration (i.e., after executing the loop body, but before evaluating the conditional expression). As with while loops, since blocks are just (compound) statements, the loop body can also be a block in which case the syntax is as follows. 1 2 3 for ( initialization_stmt ; cond_expr ; increment_stmt ; ) { loop_body ; } An example C program that uses a for loop is shown below. This program includes a mul function that implements integer multiplication through repeated addition. In this example, the initialization statement ( int i=0 ), the conditional expression ( i<y ), and the increment statement ( i=i+1 ) are all on line 4. The loop body is a single statement on line 5. The execution boxes to the left of line 5 show that parts of this line are executed four times. Let's step through the execution of this line in more detail. The very first time we consider line 4, we execute the initialization statement. The initialization statement is executed exactly once. Any variables declared in the initialization statement are only in scope during the execution of the loop, and they are deallocated when the loop is finished. So in this example, the variable i is only in scope (i.e., accessible) during the loop execution and it is deallocated when we reach line 6. The conditional expression is evaluated at the beginning of each loop iteration, and the increment statement is executed at the end of each loop iteration. So the very first time we consider line 4, we execute the initialization statement and then we evaluate the conditional expression, which in this case is true meaning we execute the loop body at least once. After executing the loop body we execute the increment statement, which in this case increments the variable i . We continue executing the loop body two more times. The fourth time we consider line 4, the conditional expression will be false and we skip over the loop body. So in summary, the initialization statement is executed once, the conditional expression is evaluated four times, and the increment statement is executed three times. Activity 18: State Diagram for Function to Count Digits with for Loop Consider the following program which includes a function to count the number of decimal digits in a given parameter. This function uses a for loop. Draw a state diagram corresponding to the execution of this program. Activity 19: Write Function to Output Sequence with for Loop Use Repl.it to develop a function that takes an integer parameter ( N ) and outputs a sequence according to the pattern below. The function should always return 0. N Output 0 0 1 0 _ 2 0 _ 2 3 0 _ 2 _ 4 0 _ 2 _ 4 5 0 _ 2 _ 4 _ 6 0 _ 2 _ 4 _ 5 Basically the output is a sequence of integers with the odd integers replaced with an underscore ( _ ). Use a for loop. The function prototype is shown below. 1 int print_seq( int x ) Here is an initial Repl.it to get you started. https://repl.it/@cbatten/SFU-CMPT-431-T01-notes-activity5","title":"6.2. for Loops"},{"location":"SFU-CMPT-431-T01-intro-c/#7-syntactic-sugar","text":"Syntactic sugar adds new syntax but not new semantics. We can explain what a given piece of syntactic sugar means by simple showing how to transform the sugar into equivalent but previously designed syntax. Syntactic sugar simplifies certain programming patterns, but again does not introduce any fundamentally new behavior. for loops are actually just syntactic sugar for a specific common use case of while loops. The following two loops are equivalent. 1 2 3 4 5 6 7 8 9 10 11 for ( int i = 0; i < y; i = i+1 ) { z = z + x; } { int i = 0; // initialization statement while ( i < y ) { // conditional expression z = z + x; i = i + 1; // increment statement } } This equivalence should clarify some of our earlier discussion. The initialization statement on line 6 is executed exactly once before starting the execution of the loop. The conditional expression is evaluated before executing the loop body, and the increment statement is executed at the end of each iteration (before we evaluate the conditional expression for the next iteration). C provides several assignment operators that are just syntactic sugar for common programming patterns. Sugar Equivalent Syntax x += y x = x + y x -= y x = x - y x *= y x = x * y x /= y x = x / y C also provides postfix and prefix operators that are useful for incrementing and decrementing variables. Sugar Equivalent Syntax Value x++ x = x + 1 x ++x x = x + 1 x + 1 x-- x = x - 1 x --x x = x - 1 x - 1 The difference between the postfix versions ( x++ ) and the prefix versions ( ++x ) has to do with how these expressions are evaluated. The value of x++ is x , but the value of ++x is x + 1 . For example, consider the following simple program which uses a postfix operator. 1 2 int i = 1; int j = i++; After executing these two statements, the value of i will be 2 and the value of j will be 1. Now consider the following simple program which uses a prefix operator. 1 2 int i = 1; int j = ++i; After executing these two statements, the value of i will be 2 and the value of j will also be 2. C provides a compact way to write if/else statements using the ternary operator. The syntax for the ternary operator is as follows. 1 ( conditional_expression ) ? then_expression : else_expression Thus the following two functions are equivalent. 1 2 3 4 5 6 7 8 9 10 11 int min( int x, int y ) { if ( x < y ) return x; return y; } int min( int x, int y ) { return ( x < y ) ? x : y; } We have now introduce several new operators, so we need to update our operator precedence table. Category Operator Associativity Postfix a++ a-- left to right Unary ! ++a --a right to left Multiplicative * / % left to right Additive + - left to right Relational < <= > >= left to right Equality == != left to right Logical AND && left to right Logical OR || left to right Assignment = += -= *= /= a?b:c right to left","title":"7. Syntactic Sugar"},{"location":"SFU-CMPT-431-coding-conventions/","text":"Coding Conventions \u00b6 Any significant programming project will usually require developers to use a standardized set of coding conventions. These conventions might be set by a company, the leaders of an open-source project, or simply through historical precedent. Standardized coding conventions enable code written by multiple developers to be consistent and improves readability, maintainability, and extensibility. We have developed a simple set of coding conventions for ECE 2400 that we would like you to use in all programming assignments. Keep in mind that these are just guidelines, and there may be situations where it is appropriate to defy a convention if this ultimately improves the overall code quality. Note that some of these conventions have been adapted from the Google C++ Style Guide . In general, anything not covered by the guidelines in this document should assume the Google style guide. 1. Directories and Files \u00b6 This section discusses the physical structure of how files should be organized in a project. 1.1. Directories \u00b6 All header, inline, data, and source files should be in a single src directory. All tests should be a in a single tests directory. Anything other than ad-hoc testing should always be done in a separate build directory. 1.2. File Names \u00b6 Files should be named in all lowercase and should use a dash ( - ) to separate words. C source files should use the .c filename extension, and C++ source files should use the .cc filename extension. Header files should use the .h filename extension, and inline files should use the .inl filename extension. Data files that contain C/C++ code and are meant to be included using the C preprocessor should use the .dat filename extension. All test programs should end in -test.c . All evaluation programs should end in -eval.c . 1.3. Header and Inline Files \u00b6 All header files should be self-contained. A header should include all other headers it needs. The definitions for template and inline functions should be placed in a separate .inl file and included at the end of the header. Every header should use include guards where the name of the include guard preprocessor macro is derived directly from the filename. For example, a header file named foo-bar.h would use the following include guards: 1 2 3 4 #ifndef FOO_BAR_H #define FOO_BAR_H #endif // FOO_BAR_H 2. Formatting \u00b6 This section discusses general formatting that is common across all kinds of files. 2.1. Line Length \u00b6 Lines in all files should in general be less than 80 characters. Using less than 74 characters is ideal since this is a natural width that enables reasonable font sizes to be used when using side-by-side code development with two listings on modern laptops and side-by-side code development with three to four listings on 24\" to 27\" monitors. Lines longer than 80 characters should be avoided unless there is a compelling reason to use longer lines to increase code quality. 2.2. Indentation \u00b6 Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int gcd ( int x , int y ) { while ( y != 0 ) { if ( x < y ) { int temp = x ; y = temp ; x = y ; } else { x = x - y ; } } return x ; } 2.3. Vertical Whitespace \u00b6 Vertical whitspace can and should be used to separate conceptually distinct portions of your code. A blank line within a block of code serves like a paragraph break in prose: visually separating two thoughts. Vertical whitespace should be limited to a single blank line. Do not use two or more blank lines in a row. Do not include a blank line at the beginning and end of the function body in a function definition. So this is incorrect: 1 2 3 4 5 6 7 int foo () { stmt1 ; return 0 ; } This is correct: 1 2 3 4 5 int foo () { stmt1 ; return 0 ; } 2.4. Horizontal Whitespace \u00b6 Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. In general, horizontal whitespace should be used to separate distinct conceptual \"tokens\". Do not cram all of the characters in an expression together without any horizontal whitespace. There should be white space around binary operators. Here is an example: 1 2 int a = b * c ; // incorrect int a = b * c ; // correct Use explicit parenthesis to make operator precendence explicit: 1 2 int a = a < 0 && b != 0 ; // incorrect int a = ( ( a < 0 ) && ( b != 0 ) ); // correct In some cases, we should not include whitespace around an operator because the operator is not delimiting two distinct conceptual \"tokens\". Here are some examples: 1 2 3 4 5 6 7 8 int a = obj . field ; // incorrect int a = obj . field ; // correct int a = obj -> field ; // incorrect int a = obj -> field ; // correct obj . method ( b ); // incorrect obj . method ( b ); // correct obj -> method ( b ); // incorrect obj -> method ( b ); // correct 2.5. Variable Declarations \u00b6 There should be whitespace around the assignment operator. Here is an example: 1 2 int a = 3 ; // incorrect int a = 3 ; // correct If possible, consder vertically aligning the variable names and assignment operators for related variables: 1 2 unsigned int a = 32 ; int * a_ptr = & a ; Never declare multiple variables in a single statement. Always use multiple statements. Here is an example: 1 2 3 int a , b ; // incorrect int a ; // correct int b ; // correct 2.6. Conditional Statements \u00b6 if conditional statements should look like this: 1 2 3 4 5 6 7 8 9 if ( conditional_expression0 ) { statement0 ; } else if ( conditional_expression1 ) { statement1 ; } else { statement2 ; } Notice the use of spaces inside the parentheses since the () tokens should be conceptually separated from the conditional expression. If you use curly braces for one part of an if/then/else statement you must use them for all parts of the statement. Avoid single line if statements: 1 2 3 if ( conditional_expression0 ) return 1 ; // incorrect if ( conditional_expression0 ) // correct return 0 ; // correct 2.7. Iteration Statements \u00b6 for loops should look like this: 1 2 3 for ( int i = 0 ; i < size ; i ++ ) { loop_body ; } Notice the extra horizontal whitespace used to separate the parentheses from the initialization statement and the increment statement. The open curly brace should be on the same line as the for statement. 2.8. Function Definitions \u00b6 Function definitions should look like this: 1 2 3 4 int foo_bar ( int a , int b ) { function_body ; } Insert space inside the parenthesis. Notice that for functions the open curly brace goes on its own line. Do not insert a space between the function name and the open parenthesis. So this is incorrect: 1 2 3 4 5 // incorrect int foo_bar ( int a , int b ) { function_body ; } 2.9. Function Calls \u00b6 Function calls should usually use whitespace inside the parenthesis. For example: 1 int result = gcd ( 10 , 15 ); If there is a single parameter, sometimes it may be more appropriate to eliminate the whitespace inside the parenthesis. 3. Naming \u00b6 3.1. Type Names \u00b6 For C programs, the names of user-defined types should usually be all lowercase, use underscores ( _ ) to separate words, and use a _t suffix. 1 typedef unsigned int uint_t ; For C++ programs, the names of user-defined types should usually use CamelCase. 1 2 3 4 class FooBar { ... }; When specifying pointer types, the * should be placed with the type without whitespace: 1 2 3 int * a_ptr ; // incorrect int * a_ptr ; // incorrect int * a_ptr ; // correct As a reminder, never declare multiple variables in a single statement. This is never allowed: 1 int *a_ptr, *b_ptr; // not allowed! 3.2. Variable Names \u00b6 The names of variables should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for variable names. For pointers, use a _ptr or _p suffix. For data member fields, use a m_ prefix. While single letter variable names are common in the lecture examples, single letter variable names should be very rare in real code. 3.3. Function/Method Names \u00b6 The names of free functions and methods should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for function or method names. 4. Comments \u00b6 Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments. When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous \u2014 the next one may be you! Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C/C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing. 4.1. Comment Style \u00b6 Use // comments. These are perfectly acceptable now in C99. Do not use the older /* */ comments. Include a space after // before starting your comment: 1 2 //without space, incorrect formatting // with space, correct formatting 4.2. File Comments \u00b6 All files should include a \"title block\". This is a comment at the very beginning of the file which gives the name of the file and a brief description of the purpose and contents of the file. Title blocks should use the following format: 1 2 3 4 //========================================================================= // foo-bar.h //========================================================================= // Description of the purpose and contents of this file. The horizontal lines used in the title block should extend exactly 74 characters (i.e., two '/' characters and 72 = characters). You do not need to duplicate comments between the .h and .cc . Often the header will have a description of the interface, and the source file will discuss the broad implementation approach. 4.3. Function Comments \u00b6 Almost every function declaration in the header should have comments immediately preceding it that describe what the function does and how to use it. These comments may be omitted only if the function is simple and obvious. These comments should be descriptive (\"Opens the file\") rather than imperative (\"Open the file\"); the comment describes the function, it does not tell the function what to do. In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition. Every function definition in the source file should have a comment like this: 1 2 3 4 //------------------------------------------------------------------------ // foo_bar() //------------------------------------------------------------------------ // optional high-level discussion of implementation approach 4.4. Old Comments \u00b6 Do not leave old comments in the source file. So you must remove comments that were provided by the instructors. 5. Scoping \u00b6 This section discusses use of local and global variables. 5.1. Local Variables \u00b6 Place a function's variables in the narrowest scope possible. C99 no longer requires all variables to be declared at the beginning of a function, so declare functions close to where they are initialized. 5.2. Static and Global Variables \u00b6 Do not use non-const static or global variables unless there is a very good reason to do so. Const global variables are allowed and should definitely be used instead of preprocessor defines. 6. C Pre-processor \u00b6 Using the C pre-processor should be avoided. Use of the C pre-processor should usually be limited to include guards and the UTST macros. When the C pre-processor must be used, pre-processor macro names should be in all capital letters and use an underscore ( _ ) to separate words. Do not use the C pre-processor to declare global constants. Use const global variables instead. 7. Examples \u00b6 Here is an example of an incorrectly formatted for loop: 1 2 3 for ( int i = 0 ; i < n ; i ++ ){ a += c ; } There should be a space inside the parenthesis and no space between i and ++ . There should be a space after the closing parenthesis and the open curly brace. Here is the same code formatted correctly: 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { a += c ; } Here is an example of an incorrectly formatted if statement: 1 2 3 4 5 6 if ( a < 0 && b != 0 ){ c = 1 / c ; } else ( x % 2 == 0 ){ ... } There should be a space inside the parenthesis and we need extra parenthesis to make the operator precedence more explicit. We also need a space between the closing parenthesis and the open curly brace. 1 2 3 4 5 6 if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c ; } else ( ( x % 2 ) == 0 ) { ... } Once we have multiple levels of nested parenthesis, it might be more readable to do something like this: 1 2 3 4 5 6 if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c ; } else ( ( x % 2 ) == 0 ) { ... } Here is an example of a poorly formatted return statement: 1 2 3 4 5 6 void foo () { ... return bar ( x ) * bar ( y ); } Indentation should be used to make this more clear: 1 2 3 4 5 6 void foo () { ... return bar ( x ) * bar ( y ); } This code does not include spaces around the assignment operator, and isn't even consistent in its formatting: 1 2 3 double foo = b ; int c = bar ; double e = 1 ; This should look like this: 1 2 3 double foo = b ; int c = bar ; double e = 1 ; Notice how we lined up the variable names and the assignment operators vertically. Here is an example of incorrectly formatted code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int gcd ( int x , int y ){ while ( y != 0 ) { if ( x < y ){ int t = x ; x = temp ; x = y ; } else x = x - y ; } return x ; } Here is an example of correctly formatted code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //------------------------------------------------------------------------ // gcd() //------------------------------------------------------------------------ int gcd ( int x , int y ) { // iterate until GCD is found while ( y != 0 ) { if ( x < y ) { // swap x and y int temp = x ; y = temp ; x = y ; } else { x = x - y ; } } return x ; }","title":"SFU CMPT 431 coding conventions"},{"location":"SFU-CMPT-431-coding-conventions/#coding-conventions","text":"Any significant programming project will usually require developers to use a standardized set of coding conventions. These conventions might be set by a company, the leaders of an open-source project, or simply through historical precedent. Standardized coding conventions enable code written by multiple developers to be consistent and improves readability, maintainability, and extensibility. We have developed a simple set of coding conventions for ECE 2400 that we would like you to use in all programming assignments. Keep in mind that these are just guidelines, and there may be situations where it is appropriate to defy a convention if this ultimately improves the overall code quality. Note that some of these conventions have been adapted from the Google C++ Style Guide . In general, anything not covered by the guidelines in this document should assume the Google style guide.","title":"Coding Conventions"},{"location":"SFU-CMPT-431-coding-conventions/#1-directories-and-files","text":"This section discusses the physical structure of how files should be organized in a project.","title":"1. Directories and Files"},{"location":"SFU-CMPT-431-coding-conventions/#11-directories","text":"All header, inline, data, and source files should be in a single src directory. All tests should be a in a single tests directory. Anything other than ad-hoc testing should always be done in a separate build directory.","title":"1.1. Directories"},{"location":"SFU-CMPT-431-coding-conventions/#12-file-names","text":"Files should be named in all lowercase and should use a dash ( - ) to separate words. C source files should use the .c filename extension, and C++ source files should use the .cc filename extension. Header files should use the .h filename extension, and inline files should use the .inl filename extension. Data files that contain C/C++ code and are meant to be included using the C preprocessor should use the .dat filename extension. All test programs should end in -test.c . All evaluation programs should end in -eval.c .","title":"1.2. File Names"},{"location":"SFU-CMPT-431-coding-conventions/#13-header-and-inline-files","text":"All header files should be self-contained. A header should include all other headers it needs. The definitions for template and inline functions should be placed in a separate .inl file and included at the end of the header. Every header should use include guards where the name of the include guard preprocessor macro is derived directly from the filename. For example, a header file named foo-bar.h would use the following include guards: 1 2 3 4 #ifndef FOO_BAR_H #define FOO_BAR_H #endif // FOO_BAR_H","title":"1.3. Header and Inline Files"},{"location":"SFU-CMPT-431-coding-conventions/#2-formatting","text":"This section discusses general formatting that is common across all kinds of files.","title":"2. Formatting"},{"location":"SFU-CMPT-431-coding-conventions/#21-line-length","text":"Lines in all files should in general be less than 80 characters. Using less than 74 characters is ideal since this is a natural width that enables reasonable font sizes to be used when using side-by-side code development with two listings on modern laptops and side-by-side code development with three to four listings on 24\" to 27\" monitors. Lines longer than 80 characters should be avoided unless there is a compelling reason to use longer lines to increase code quality.","title":"2.1. Line Length"},{"location":"SFU-CMPT-431-coding-conventions/#22-indentation","text":"Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int gcd ( int x , int y ) { while ( y != 0 ) { if ( x < y ) { int temp = x ; y = temp ; x = y ; } else { x = x - y ; } } return x ; }","title":"2.2. Indentation"},{"location":"SFU-CMPT-431-coding-conventions/#23-vertical-whitespace","text":"Vertical whitspace can and should be used to separate conceptually distinct portions of your code. A blank line within a block of code serves like a paragraph break in prose: visually separating two thoughts. Vertical whitespace should be limited to a single blank line. Do not use two or more blank lines in a row. Do not include a blank line at the beginning and end of the function body in a function definition. So this is incorrect: 1 2 3 4 5 6 7 int foo () { stmt1 ; return 0 ; } This is correct: 1 2 3 4 5 int foo () { stmt1 ; return 0 ; }","title":"2.3. Vertical Whitespace"},{"location":"SFU-CMPT-431-coding-conventions/#24-horizontal-whitespace","text":"Absolutely no tabs are allowed. Only spaces are allowed for the purposes of indentation. The standard number of spaces per level of indentation is two. In general, horizontal whitespace should be used to separate distinct conceptual \"tokens\". Do not cram all of the characters in an expression together without any horizontal whitespace. There should be white space around binary operators. Here is an example: 1 2 int a = b * c ; // incorrect int a = b * c ; // correct Use explicit parenthesis to make operator precendence explicit: 1 2 int a = a < 0 && b != 0 ; // incorrect int a = ( ( a < 0 ) && ( b != 0 ) ); // correct In some cases, we should not include whitespace around an operator because the operator is not delimiting two distinct conceptual \"tokens\". Here are some examples: 1 2 3 4 5 6 7 8 int a = obj . field ; // incorrect int a = obj . field ; // correct int a = obj -> field ; // incorrect int a = obj -> field ; // correct obj . method ( b ); // incorrect obj . method ( b ); // correct obj -> method ( b ); // incorrect obj -> method ( b ); // correct","title":"2.4. Horizontal Whitespace"},{"location":"SFU-CMPT-431-coding-conventions/#25-variable-declarations","text":"There should be whitespace around the assignment operator. Here is an example: 1 2 int a = 3 ; // incorrect int a = 3 ; // correct If possible, consder vertically aligning the variable names and assignment operators for related variables: 1 2 unsigned int a = 32 ; int * a_ptr = & a ; Never declare multiple variables in a single statement. Always use multiple statements. Here is an example: 1 2 3 int a , b ; // incorrect int a ; // correct int b ; // correct","title":"2.5. Variable Declarations"},{"location":"SFU-CMPT-431-coding-conventions/#26-conditional-statements","text":"if conditional statements should look like this: 1 2 3 4 5 6 7 8 9 if ( conditional_expression0 ) { statement0 ; } else if ( conditional_expression1 ) { statement1 ; } else { statement2 ; } Notice the use of spaces inside the parentheses since the () tokens should be conceptually separated from the conditional expression. If you use curly braces for one part of an if/then/else statement you must use them for all parts of the statement. Avoid single line if statements: 1 2 3 if ( conditional_expression0 ) return 1 ; // incorrect if ( conditional_expression0 ) // correct return 0 ; // correct","title":"2.6. Conditional Statements"},{"location":"SFU-CMPT-431-coding-conventions/#27-iteration-statements","text":"for loops should look like this: 1 2 3 for ( int i = 0 ; i < size ; i ++ ) { loop_body ; } Notice the extra horizontal whitespace used to separate the parentheses from the initialization statement and the increment statement. The open curly brace should be on the same line as the for statement.","title":"2.7. Iteration Statements"},{"location":"SFU-CMPT-431-coding-conventions/#28-function-definitions","text":"Function definitions should look like this: 1 2 3 4 int foo_bar ( int a , int b ) { function_body ; } Insert space inside the parenthesis. Notice that for functions the open curly brace goes on its own line. Do not insert a space between the function name and the open parenthesis. So this is incorrect: 1 2 3 4 5 // incorrect int foo_bar ( int a , int b ) { function_body ; }","title":"2.8. Function Definitions"},{"location":"SFU-CMPT-431-coding-conventions/#29-function-calls","text":"Function calls should usually use whitespace inside the parenthesis. For example: 1 int result = gcd ( 10 , 15 ); If there is a single parameter, sometimes it may be more appropriate to eliminate the whitespace inside the parenthesis.","title":"2.9. Function Calls"},{"location":"SFU-CMPT-431-coding-conventions/#3-naming","text":"","title":"3. Naming"},{"location":"SFU-CMPT-431-coding-conventions/#31-type-names","text":"For C programs, the names of user-defined types should usually be all lowercase, use underscores ( _ ) to separate words, and use a _t suffix. 1 typedef unsigned int uint_t ; For C++ programs, the names of user-defined types should usually use CamelCase. 1 2 3 4 class FooBar { ... }; When specifying pointer types, the * should be placed with the type without whitespace: 1 2 3 int * a_ptr ; // incorrect int * a_ptr ; // incorrect int * a_ptr ; // correct As a reminder, never declare multiple variables in a single statement. This is never allowed: 1 int *a_ptr, *b_ptr; // not allowed!","title":"3.1. Type Names"},{"location":"SFU-CMPT-431-coding-conventions/#32-variable-names","text":"The names of variables should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for variable names. For pointers, use a _ptr or _p suffix. For data member fields, use a m_ prefix. While single letter variable names are common in the lecture examples, single letter variable names should be very rare in real code.","title":"3.2. Variable Names"},{"location":"SFU-CMPT-431-coding-conventions/#33-functionmethod-names","text":"The names of free functions and methods should always be all lowercase with underscores ( _ ) to separate words. Do not use CamelCase for function or method names.","title":"3.3. Function/Method Names"},{"location":"SFU-CMPT-431-coding-conventions/#4-comments","text":"Though a pain to write, comments are absolutely vital to keeping our code readable. The following rules describe what you should comment and where. But remember: while comments are very important, the best code is self-documenting. Giving sensible names to types and variables is much better than using obscure names that you must then explain through comments. When writing your comments, write for your audience: the next contributor who will need to understand your code. Be generous \u2014 the next one may be you! Do not state the obvious. In particular, don't literally describe what code does, unless the behavior is nonobvious to a reader who understands C/C++ well. Instead, provide higher level comments that describe why the code does what it does, or make the code self describing.","title":"4. Comments"},{"location":"SFU-CMPT-431-coding-conventions/#41-comment-style","text":"Use // comments. These are perfectly acceptable now in C99. Do not use the older /* */ comments. Include a space after // before starting your comment: 1 2 //without space, incorrect formatting // with space, correct formatting","title":"4.1. Comment Style"},{"location":"SFU-CMPT-431-coding-conventions/#42-file-comments","text":"All files should include a \"title block\". This is a comment at the very beginning of the file which gives the name of the file and a brief description of the purpose and contents of the file. Title blocks should use the following format: 1 2 3 4 //========================================================================= // foo-bar.h //========================================================================= // Description of the purpose and contents of this file. The horizontal lines used in the title block should extend exactly 74 characters (i.e., two '/' characters and 72 = characters). You do not need to duplicate comments between the .h and .cc . Often the header will have a description of the interface, and the source file will discuss the broad implementation approach.","title":"4.2. File Comments"},{"location":"SFU-CMPT-431-coding-conventions/#43-function-comments","text":"Almost every function declaration in the header should have comments immediately preceding it that describe what the function does and how to use it. These comments may be omitted only if the function is simple and obvious. These comments should be descriptive (\"Opens the file\") rather than imperative (\"Open the file\"); the comment describes the function, it does not tell the function what to do. In general, these comments do not describe how the function performs its task. Instead, that should be left to comments in the function definition. Every function definition in the source file should have a comment like this: 1 2 3 4 //------------------------------------------------------------------------ // foo_bar() //------------------------------------------------------------------------ // optional high-level discussion of implementation approach","title":"4.3. Function Comments"},{"location":"SFU-CMPT-431-coding-conventions/#44-old-comments","text":"Do not leave old comments in the source file. So you must remove comments that were provided by the instructors.","title":"4.4. Old Comments"},{"location":"SFU-CMPT-431-coding-conventions/#5-scoping","text":"This section discusses use of local and global variables.","title":"5. Scoping"},{"location":"SFU-CMPT-431-coding-conventions/#51-local-variables","text":"Place a function's variables in the narrowest scope possible. C99 no longer requires all variables to be declared at the beginning of a function, so declare functions close to where they are initialized.","title":"5.1. Local Variables"},{"location":"SFU-CMPT-431-coding-conventions/#52-static-and-global-variables","text":"Do not use non-const static or global variables unless there is a very good reason to do so. Const global variables are allowed and should definitely be used instead of preprocessor defines.","title":"5.2. Static and Global Variables"},{"location":"SFU-CMPT-431-coding-conventions/#6-c-pre-processor","text":"Using the C pre-processor should be avoided. Use of the C pre-processor should usually be limited to include guards and the UTST macros. When the C pre-processor must be used, pre-processor macro names should be in all capital letters and use an underscore ( _ ) to separate words. Do not use the C pre-processor to declare global constants. Use const global variables instead.","title":"6. C Pre-processor"},{"location":"SFU-CMPT-431-coding-conventions/#7-examples","text":"Here is an example of an incorrectly formatted for loop: 1 2 3 for ( int i = 0 ; i < n ; i ++ ){ a += c ; } There should be a space inside the parenthesis and no space between i and ++ . There should be a space after the closing parenthesis and the open curly brace. Here is the same code formatted correctly: 1 2 3 for ( int i = 0 ; i < n ; i ++ ) { a += c ; } Here is an example of an incorrectly formatted if statement: 1 2 3 4 5 6 if ( a < 0 && b != 0 ){ c = 1 / c ; } else ( x % 2 == 0 ){ ... } There should be a space inside the parenthesis and we need extra parenthesis to make the operator precedence more explicit. We also need a space between the closing parenthesis and the open curly brace. 1 2 3 4 5 6 if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c ; } else ( ( x % 2 ) == 0 ) { ... } Once we have multiple levels of nested parenthesis, it might be more readable to do something like this: 1 2 3 4 5 6 if ( ( a < 0 ) && ( b != 0 ) ) { c = 1 / c ; } else ( ( x % 2 ) == 0 ) { ... } Here is an example of a poorly formatted return statement: 1 2 3 4 5 6 void foo () { ... return bar ( x ) * bar ( y ); } Indentation should be used to make this more clear: 1 2 3 4 5 6 void foo () { ... return bar ( x ) * bar ( y ); } This code does not include spaces around the assignment operator, and isn't even consistent in its formatting: 1 2 3 double foo = b ; int c = bar ; double e = 1 ; This should look like this: 1 2 3 double foo = b ; int c = bar ; double e = 1 ; Notice how we lined up the variable names and the assignment operators vertically. Here is an example of incorrectly formatted code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int gcd ( int x , int y ){ while ( y != 0 ) { if ( x < y ){ int t = x ; x = temp ; x = y ; } else x = x - y ; } return x ; } Here is an example of correctly formatted code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //------------------------------------------------------------------------ // gcd() //------------------------------------------------------------------------ int gcd ( int x , int y ) { // iterate until GCD is found while ( y != 0 ) { if ( x < y ) { // swap x and y int temp = x ; y = temp ; x = y ; } else { x = x - y ; } } return x ; }","title":"7. Examples"},{"location":"SFU-CMPT-431-faq-c-basics/","text":"========================================================================== This is a collection of commonly asked questions on C basics. Q: How do understand the include guard? \u00b6 I noticed this on the sec2 handout 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif If I have already defined a macro, then excute the #ifndef directive, then include the content again. How does this operation skip over the contents of the same file? A: How do understand the include guard? \u00b6 From my understanding, what the #ifindef conditional does is check to see if this macro has been defined already. If it has not then, the code below the #ifindef line is run and the macro us defined. On the other hand, if it already exists, meaning it has a value, these lines below #ifindef will not be processed. So, the preprocessor determines if the macro exists before including the leading code in the compilation process. In other words, if something has a value during the course of the program, it is stored and so not changed again during the rest of the compilation process. An example I saw online that might help: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <stdio.h> #define YEARS_OLD 12 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( \"TechOnTheNet is over %d years old. \\n \" , YEARS_OLD ); return 0 ; } In this case, since YEARS_OLD is defined before ifndef, the code below it will be skipped over because the macro is already defined and so the compiler will skip over to #endif. If you run this code, you will see that YEARS_OLD has a value of 12. If we removed the first #define statement and just had this: 1 2 3 4 5 6 7 8 9 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( \"TechOnTheNet is over %d years old. \\n \" , YEARS_OLD ); return 0 ; } Then the lines under #ifndef would be processed and YEARS_OLD would attain a value of 10. Hope this answers your question!","title":"SFU CMPT 431 faq c basics"},{"location":"SFU-CMPT-431-faq-c-basics/#q-how-do-understand-the-include-guard","text":"I noticed this on the sec2 handout 1 2 3 4 5 6 #ifndef WARM_COLORS_TXT #define WARM_COLORS_TXT red orange yellow #endif If I have already defined a macro, then excute the #ifndef directive, then include the content again. How does this operation skip over the contents of the same file?","title":"Q: How do understand the include guard?"},{"location":"SFU-CMPT-431-faq-c-basics/#a-how-do-understand-the-include-guard","text":"From my understanding, what the #ifindef conditional does is check to see if this macro has been defined already. If it has not then, the code below the #ifindef line is run and the macro us defined. On the other hand, if it already exists, meaning it has a value, these lines below #ifindef will not be processed. So, the preprocessor determines if the macro exists before including the leading code in the compilation process. In other words, if something has a value during the course of the program, it is stored and so not changed again during the rest of the compilation process. An example I saw online that might help: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <stdio.h> #define YEARS_OLD 12 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( \"TechOnTheNet is over %d years old. \\n \" , YEARS_OLD ); return 0 ; } In this case, since YEARS_OLD is defined before ifndef, the code below it will be skipped over because the macro is already defined and so the compiler will skip over to #endif. If you run this code, you will see that YEARS_OLD has a value of 12. If we removed the first #define statement and just had this: 1 2 3 4 5 6 7 8 9 #ifndef YEARS_OLD #define YEARS_OLD 10 #endif int main () { printf ( \"TechOnTheNet is over %d years old. \\n \" , YEARS_OLD ); return 0 ; } Then the lines under #ifndef would be processed and YEARS_OLD would attain a value of 10. Hope this answers your question!","title":"A: How do understand the include guard?"},{"location":"SFU-CMPT-431-index/","text":"CMPT 431 - Parallel and Distributed Systems \u00b6 Public Course Website: http://www.cs.sfu.ca/~ashriram/Courses/CMPT431 This is the CMPT 431 systems programming documentation site. It includes topic notes, discussion section handouts, tutorials, and programming assignment handouts. If you find any bugs or errors with this documentation, please post on Piazza or feel free to create a pull request in the corresponding documentation repo .","title":"CMPT 431 - Parallel and Distributed Systems"},{"location":"SFU-CMPT-431-index/#cmpt-431-parallel-and-distributed-systems","text":"Public Course Website: http://www.cs.sfu.ca/~ashriram/Courses/CMPT431 This is the CMPT 431 systems programming documentation site. It includes topic notes, discussion section handouts, tutorials, and programming assignment handouts. If you find any bugs or errors with this documentation, please post on Piazza or feel free to create a pull request in the corresponding documentation repo .","title":"CMPT 431 - Parallel and Distributed Systems"},{"location":"SFU-CMPT-431-memory-debugging/","text":"How to debug memory problems? \u00b6 Author: Tuan Ta Date : Sep 26, 2018 While dynamic memory allocation gives us a lot of freedom in keeping some blocks of memory alive across function calls, misusing dynamically allocated memory is often the most common cause of memory corruptions (e.g., segmentation fault). In this tutorial, I'll walk you through some common mistakes in using dynamic memory allocation and pointer. For each mistake, I'll show you how to detect it using a powerful memory checking tool called valgrind . 1. Memory leak \u00b6 Let's consider this program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 # include < stdlib . h > 2 # include < stdio . h > 3 4 int main ( void ) { 5 6 // Allocate an int on the heap 7 int* mem_ptr = ( int* ) malloc( sizeof( int) ) ; 8 9 // Initialize that int variable 10 *mem_ptr = 10 ; 11 12 printf(\" Before : mem_ptr : address = % lx , value = % d \\ n \", mem_ptr, *mem_ptr); 13 14 // Declare a new int variable on the stack 15 int a = 20; 16 17 // Reuse mem_ptr to point to \" a \" 18 mem_ptr = &a; 19 20 printf(\" After : mem_ptr : address = % lx , value = % d \\ n \" , mem_ptr , * mem_ptr ); 21 22 // How do I get back my memory on the heap? 23 24 return 0 ; 25 } We first allocate a block of memory on the heap (in line 7). Then, we assign mem_ptr to point to a different block of memory on the stack (in line 18). By assigning \"mem_ptr\" to a different block of memory, we lose the only way to go back to our heap memory block. Therefore, in line 22, we cannot free that heap memory block. There're actually two problems here: First, since there is no pointer pointing to the block of memory on the heap, that block of memory becomes \"orphan\". Second, since we do not or cannot free the block of memory, we lose it in our program. This problem is called \"memory leak\". Now, let's compile and run the program: 1 2 3 4 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o mem-leak mem-leak.c ECE2400: ~/SFU-CMPT-431/tests % ./mem-leak Before: mem_ptr: address = 0x1a17010, value = 10 After: mem_ptr: address = 0x7fffabe3582c, value = 20 Notice that there is no compilation error! And our program runs \"completely fine\", or does it? Well, if your memory leak is small enough (e.g., in this program, we lose only 4 bytes of memory), then your program may not crash. Think about if your memory leak accumulates over time in a long program, then something nasty (e.g., segmentation fault) will happen! We don't want that. So how to detect memory leak. Luckily, we have a powerful tool called \"Valgrind\" to help us. Let's use the tool to run our buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./mem-leak ==14973== Memcheck, a memory error detector ==14973== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==14973== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==14973== Command: ./mem-leak ==14973== Before: mem_ptr: address = 0x5202040, value = 10 After: mem_ptr: address = 0xffefff4dc, value = 20 ==14973== ==14973== HEAP SUMMARY: ==14973== in use at exit: 4 bytes in 1 blocks ==14973== total heap usage: 1 allocs, 0 frees, 4 bytes allocated ==14973== ==14973== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==14973== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==14973== by 0x40047D: main (mem-leak.c:7) ==14973== ==14973== LEAK SUMMARY: ==14973== definitely lost: 4 bytes in 1 blocks ==14973== indirectly lost: 0 bytes in 0 blocks ==14973== possibly lost: 0 bytes in 0 blocks ==14973== still reachable: 0 bytes in 0 blocks ==14973== suppressed: 0 bytes in 0 blocks ==14973== ==14973== For counts of detected and suppressed errors, rerun with: -v ==14973== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Here I run valgrind with two options --leak-check=full that tells valgrind to give details about any possible memory leak in our program and --error-exitcode=1 that tells valgrind to return an error code of 1 if any memory error is detected. Let's dive into what valgrind is telling us here. We thought our program ran fine, but Valgrind reported that we \"definitely lost\" 4 bytes of memory on the heap and that no memory block on the heap was \"still reachable\" at the end of the program. The report tells us exactly what we expect in the buggy program right? Our heap memory block has no pointer pointing to it at the end of the program, so it is not reachable. Since there is no way to reach to the block, we could not free that block. Therefore, that block of heap memory is definitely lost. When you compile your program with -g option, valgrind can tell you where the leak exactly is in our program. In this case, we lost 4 bytes that were allocated in line 7 of mem-leak.c . Let's try to fix the memory bug and re-run valgrind on your own to verify the leak is actually fixed. 2. Double free your memory \u00b6 Another common problem is that a block of memory on the heap can be freed twice. Let's look at this buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1 # include < stdlib . h > 2 # include < stdio . h > 3 4 void foo ( int * mem_ptr ) { 5 printf(\"In foo(): mem_ptr : address = % p , value = % d \\ n \", mem_ptr, *mem_ptr); 6 free( mem_ptr ); 7 } 8 9 int main( void ) { 10 11 // Allocate an int on the heap 12 int* mem_ptr = ( int* ) malloc( sizeof( int) ); 13 14 // Initialize that int variable 15 *mem_ptr = 10; 16 17 printf(\" In main () : mem_ptr : address = % p , value = % d \\ n \" , mem_ptr , * mem_ptr ); 18 19 // Call foo 20 foo( mem_ptr ) ; 21 22 // Did foo free mem_ptr? Maybe not, so let's just free it here just in case! 23 free( mem_ptr ) ; 24 25 return 0 ; 26 } In line 12, we allocate a block of memory on the heap. In line 20, we pass \"mem_ptr\" to foo() . In line 6, foo() after printing the value pointed by \"mem_ptr\" frees the block. In line 23, main() tries to re-free \"mem_ptr\". You may think that in this small program, it's easy to see that \"mem_ptr\" is freed twice, right? In reality, it may be really hard to see this problem especially when multiple pointers point to the same block of memory (i.e., this is called pointer aliasing). Let's run the program and see what will happen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o double-free double-free.c ECE2400: ~/SFU-CMPT-431/tests % ./double-free In main(): mem_ptr: address = 0xcec010, value = 10 In foo(): mem_ptr: address = 0xcec010, value = 10 *** Error in `./double-free': double free or corruption (fasttop): 0x0000000000cec010 *** ======= Backtrace: ========= /lib64/libc.so.6(+0x81429)[0x7f5564d81429] ./double-free[0x4004f8] /lib64/libc.so.6(__libc_start_main+0xf5)[0x7f5564d223d5] ./double-free[0x400525] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00600000-00601000 r--p 00000000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00601000-00602000 rw-p 00001000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00cec000-00d0d000 rw-p 00000000 00:00 0 [heap] 7f5560000000-7f5560021000 rw-p 00000000 00:00 0 7f5560021000-7f5564000000 ---p 00000000 00:00 0 7f5564aea000-7f5564aff000 r-xp 00000000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564aff000-7f5564cfe000 ---p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564cfe000-7f5564cff000 r--p 00014000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564cff000-7f5564d00000 rw-p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564d00000-7f5564ec3000 r-xp 00000000 fd:00 148997 /usr/lib64/libc-2.17.so 7f5564ec3000-7f55650c2000 ---p 001c3000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c2000-7f55650c6000 r--p 001c2000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c6000-7f55650c8000 rw-p 001c6000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c8000-7f55650cd000 rw-p 00000000 00:00 0 7f55650cd000-7f55650ef000 r-xp 00000000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652c6000-7f55652c9000 rw-p 00000000 00:00 0 7f55652eb000-7f55652ee000 rw-p 00000000 00:00 0 7f55652ee000-7f55652ef000 r--p 00021000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652ef000-7f55652f0000 rw-p 00022000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652f0000-7f55652f1000 rw-p 00000000 00:00 0 7ffeec44c000-7ffeec46e000 rw-p 00000000 00:00 0 [stack] 7ffeec485000-7ffeec487000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] Aborted (core dumped) Oopps, our program crashed! No worries. Our friend valgrind can help us detect what went wrong. Let's run valgrind and see what it reports. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./double-free ==23220== Memcheck, a memory error detector ==23220== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==23220== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==23220== Command: ./double-free ==23220== In main(): mem_ptr: address = 0x5202040, value = 10 In foo(): mem_ptr: address = 0x5202040, value = 10 ==23220== Invalid free() / delete / delete[] / realloc() ==23220== at 0x4C2AC7D: free (vg_replace_malloc.c:530) ==23220== by 0x4004F7: main (double-free.c:23) ==23220== Address 0x5202040 is 0 bytes inside a block of size 4 free'd ==23220== at 0x4C2AC7D: free (vg_replace_malloc.c:530) ==23220== by 0x4004EF: main (double-free.c:20) ==23220== Block was alloc'd at ==23220== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==23220== by 0x4004CA: main (double-free.c:12) ==23220== ==23220== ==23220== HEAP SUMMARY: ==23220== in use at exit: 0 bytes in 0 blocks ==23220== total heap usage: 1 allocs, 2 frees, 4 bytes allocated ==23220== ==23220== All heap blocks were freed -- no leaks are possible ==23220== ==23220== For counts of detected and suppressed errors, rerun with: -v ==23220== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Valgrind tells us that there was an \"invalid free()\" in line 23 of double-free.c . Thanks to Valgrind, now you know exactly what the problem is. Can you fix it on your own and re-run valgrind? 3. Invalid memory access \u00b6 Remember that C compiler does not check out-of-bounds array access. You may accidentally access some memory blocks that are not allocated. Let's consider this buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 #include <stdlib.h> 2 #include <stdio.h> 3 4 int main( void ) { 5 6 const int size = 10; 7 int* mem_ptr = ( int* ) malloc( sizeof( int ) * size ); 8 9 for ( int i = 0; i <= size; i++ ) { 10 printf( \"Initializing mem_ptr[%d] ... \\n\", i ); 11 mem_ptr[i] = i; 12 } 13 14 // Print out the array 15 for ( int i = 0; i <= size; i++ ) { 16 printf( \"mem_ptr[%d] = %d\\n\", i, mem_ptr[i] ); 17 } 18 19 // Free mem_ptr 20 free(mem_ptr); 21 22 return 0; 23 } Notice that the program allocates an array of 10 \"int\" elements on the heap (in line 7). It by mistake initializes the 11th element when i == size in line 9. Then in line 15, the program tries to read that unallocated element. When you compile and run the program, you will get something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o out-of-bound-access out-of-bound-access.c ECE2400: ~/SFU-CMPT-431/tests % ./out-of-bound-access Initializing mem_ptr[0] ... Initializing mem_ptr[1] ... Initializing mem_ptr[2] ... Initializing mem_ptr[3] ... Initializing mem_ptr[4] ... Initializing mem_ptr[5] ... Initializing mem_ptr[6] ... Initializing mem_ptr[7] ... Initializing mem_ptr[8] ... Initializing mem_ptr[9] ... Initializing mem_ptr[10] ... mem_ptr[0] = 0 mem_ptr[1] = 1 mem_ptr[2] = 2 mem_ptr[3] = 3 mem_ptr[4] = 4 mem_ptr[5] = 5 mem_ptr[6] = 6 mem_ptr[7] = 7 mem_ptr[8] = 8 mem_ptr[9] = 9 mem_ptr[10] = 10 *** Error in `./out-of-bound-access': free(): invalid next size (fast): 0x0000000001d1e010 *** ======= Backtrace: ========= /lib64/libc.so.6(+0x81429)[0x7fdf3ec46429] ./out-of-bound-access[0x400524] /lib64/libc.so.6(__libc_start_main+0xf5)[0x7fdf3ebe73d5] ./out-of-bound-access[0x400556] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 00600000-00601000 r--p 00000000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 00601000-00602000 rw-p 00001000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 01d1e000-01d3f000 rw-p 00000000 00:00 0 [heap] 7fdf38000000-7fdf38021000 rw-p 00000000 00:00 0 7fdf38021000-7fdf3c000000 ---p 00000000 00:00 0 7fdf3e9af000-7fdf3e9c4000 r-xp 00000000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3e9c4000-7fdf3ebc3000 ---p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc3000-7fdf3ebc4000 r--p 00014000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc4000-7fdf3ebc5000 rw-p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc5000-7fdf3ed88000 r-xp 00000000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ed88000-7fdf3ef87000 ---p 001c3000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef87000-7fdf3ef8b000 r--p 001c2000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef8b000-7fdf3ef8d000 rw-p 001c6000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef8d000-7fdf3ef92000 rw-p 00000000 00:00 0 7fdf3ef92000-7fdf3efb4000 r-xp 00000000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f18b000-7fdf3f18e000 rw-p 00000000 00:00 0 7fdf3f1b0000-7fdf3f1b3000 rw-p 00000000 00:00 0 7fdf3f1b3000-7fdf3f1b4000 r--p 00021000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f1b4000-7fdf3f1b5000 rw-p 00022000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f1b5000-7fdf3f1b6000 rw-p 00000000 00:00 0 7ffe872bd000-7ffe872df000 rw-p 00000000 00:00 0 [stack] 7ffe872e7000-7ffe872e9000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] Aborted (core dumped) The program crashed at the very end when it tried to free an unallocated memory block. Let's run it using valgrind: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./out-of-bound-access ==31457== Memcheck, a memory error detector ==31457== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==31457== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==31457== Command: ./out-of-bound-access ==31457== Initializing mem_ptr[0] ... Initializing mem_ptr[1] ... Initializing mem_ptr[2] ... Initializing mem_ptr[3] ... Initializing mem_ptr[4] ... Initializing mem_ptr[5] ... Initializing mem_ptr[6] ... Initializing mem_ptr[7] ... Initializing mem_ptr[8] ... Initializing mem_ptr[9] ... Initializing mem_ptr[10] ... ==31457== Invalid write of size 4 ==31457== at 0x4004E6: main (out-of-bound-access.c:11) ==31457== Address 0x5202068 is 0 bytes after a block of size 40 alloc'd ==31457== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==31457== by 0x4004D1: main (out-of-bound-access.c:7) ==31457== mem_ptr[0] = 0 mem_ptr[1] = 1 mem_ptr[2] = 2 mem_ptr[3] = 3 mem_ptr[4] = 4 mem_ptr[5] = 5 mem_ptr[6] = 6 mem_ptr[7] = 7 mem_ptr[8] = 8 mem_ptr[9] = 9 ==31457== Invalid read of size 4 ==31457== at 0x400500: main (out-of-bound-access.c:16) ==31457== Address 0x5202068 is 0 bytes after a block of size 40 alloc'd ==31457== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==31457== by 0x4004D1: main (out-of-bound-access.c:7) ==31457== mem_ptr[10] = 10 ==31457== ==31457== HEAP SUMMARY: ==31457== in use at exit: 0 bytes in 0 blocks ==31457== total heap usage: 1 allocs, 1 frees, 40 bytes allocated ==31457== ==31457== All heap blocks were freed -- no leaks are possible ==31457== ==31457== For counts of detected and suppressed errors, rerun with: -v ==31457== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) Valgrind reported an \"Invalid write of size 4\" in line 11 and an \"Invalid read of size 4\" in line 16. They're exactly where we by mistake accessed data blocks outside our allocated array. Now, you can hopefully clearly see the bug and fix it on your own. How to use valgrind in your PAs \u00b6 In PAs, we provide you a make target called \"make memcheck\" that you can use to do memory check on your tests. You can do like this 1 2 3 4 5 6 7 8 9 10 11 % # go to your PA directory % cd ${HOME}/SFU-CMPT-431/<netid>/pa2-dstruct % mkdir -p build % cd build % # run memcheck on all tests % make memcheck % # run memcheck on a single test (e.g., dlist-basic-tests) % make memcheck-dlist-basic-tests % # see reports generated by Valgrind % cd memtest-logs % geany dlist-basic-tests.log &","title":"SFU CMPT 431 memory debugging"},{"location":"SFU-CMPT-431-memory-debugging/#how-to-debug-memory-problems","text":"Author: Tuan Ta Date : Sep 26, 2018 While dynamic memory allocation gives us a lot of freedom in keeping some blocks of memory alive across function calls, misusing dynamically allocated memory is often the most common cause of memory corruptions (e.g., segmentation fault). In this tutorial, I'll walk you through some common mistakes in using dynamic memory allocation and pointer. For each mistake, I'll show you how to detect it using a powerful memory checking tool called valgrind .","title":"How to debug memory problems?"},{"location":"SFU-CMPT-431-memory-debugging/#1-memory-leak","text":"Let's consider this program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 # include < stdlib . h > 2 # include < stdio . h > 3 4 int main ( void ) { 5 6 // Allocate an int on the heap 7 int* mem_ptr = ( int* ) malloc( sizeof( int) ) ; 8 9 // Initialize that int variable 10 *mem_ptr = 10 ; 11 12 printf(\" Before : mem_ptr : address = % lx , value = % d \\ n \", mem_ptr, *mem_ptr); 13 14 // Declare a new int variable on the stack 15 int a = 20; 16 17 // Reuse mem_ptr to point to \" a \" 18 mem_ptr = &a; 19 20 printf(\" After : mem_ptr : address = % lx , value = % d \\ n \" , mem_ptr , * mem_ptr ); 21 22 // How do I get back my memory on the heap? 23 24 return 0 ; 25 } We first allocate a block of memory on the heap (in line 7). Then, we assign mem_ptr to point to a different block of memory on the stack (in line 18). By assigning \"mem_ptr\" to a different block of memory, we lose the only way to go back to our heap memory block. Therefore, in line 22, we cannot free that heap memory block. There're actually two problems here: First, since there is no pointer pointing to the block of memory on the heap, that block of memory becomes \"orphan\". Second, since we do not or cannot free the block of memory, we lose it in our program. This problem is called \"memory leak\". Now, let's compile and run the program: 1 2 3 4 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o mem-leak mem-leak.c ECE2400: ~/SFU-CMPT-431/tests % ./mem-leak Before: mem_ptr: address = 0x1a17010, value = 10 After: mem_ptr: address = 0x7fffabe3582c, value = 20 Notice that there is no compilation error! And our program runs \"completely fine\", or does it? Well, if your memory leak is small enough (e.g., in this program, we lose only 4 bytes of memory), then your program may not crash. Think about if your memory leak accumulates over time in a long program, then something nasty (e.g., segmentation fault) will happen! We don't want that. So how to detect memory leak. Luckily, we have a powerful tool called \"Valgrind\" to help us. Let's use the tool to run our buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./mem-leak ==14973== Memcheck, a memory error detector ==14973== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==14973== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==14973== Command: ./mem-leak ==14973== Before: mem_ptr: address = 0x5202040, value = 10 After: mem_ptr: address = 0xffefff4dc, value = 20 ==14973== ==14973== HEAP SUMMARY: ==14973== in use at exit: 4 bytes in 1 blocks ==14973== total heap usage: 1 allocs, 0 frees, 4 bytes allocated ==14973== ==14973== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1 ==14973== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==14973== by 0x40047D: main (mem-leak.c:7) ==14973== ==14973== LEAK SUMMARY: ==14973== definitely lost: 4 bytes in 1 blocks ==14973== indirectly lost: 0 bytes in 0 blocks ==14973== possibly lost: 0 bytes in 0 blocks ==14973== still reachable: 0 bytes in 0 blocks ==14973== suppressed: 0 bytes in 0 blocks ==14973== ==14973== For counts of detected and suppressed errors, rerun with: -v ==14973== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Here I run valgrind with two options --leak-check=full that tells valgrind to give details about any possible memory leak in our program and --error-exitcode=1 that tells valgrind to return an error code of 1 if any memory error is detected. Let's dive into what valgrind is telling us here. We thought our program ran fine, but Valgrind reported that we \"definitely lost\" 4 bytes of memory on the heap and that no memory block on the heap was \"still reachable\" at the end of the program. The report tells us exactly what we expect in the buggy program right? Our heap memory block has no pointer pointing to it at the end of the program, so it is not reachable. Since there is no way to reach to the block, we could not free that block. Therefore, that block of heap memory is definitely lost. When you compile your program with -g option, valgrind can tell you where the leak exactly is in our program. In this case, we lost 4 bytes that were allocated in line 7 of mem-leak.c . Let's try to fix the memory bug and re-run valgrind on your own to verify the leak is actually fixed.","title":"1. Memory leak"},{"location":"SFU-CMPT-431-memory-debugging/#2-double-free-your-memory","text":"Another common problem is that a block of memory on the heap can be freed twice. Let's look at this buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1 # include < stdlib . h > 2 # include < stdio . h > 3 4 void foo ( int * mem_ptr ) { 5 printf(\"In foo(): mem_ptr : address = % p , value = % d \\ n \", mem_ptr, *mem_ptr); 6 free( mem_ptr ); 7 } 8 9 int main( void ) { 10 11 // Allocate an int on the heap 12 int* mem_ptr = ( int* ) malloc( sizeof( int) ); 13 14 // Initialize that int variable 15 *mem_ptr = 10; 16 17 printf(\" In main () : mem_ptr : address = % p , value = % d \\ n \" , mem_ptr , * mem_ptr ); 18 19 // Call foo 20 foo( mem_ptr ) ; 21 22 // Did foo free mem_ptr? Maybe not, so let's just free it here just in case! 23 free( mem_ptr ) ; 24 25 return 0 ; 26 } In line 12, we allocate a block of memory on the heap. In line 20, we pass \"mem_ptr\" to foo() . In line 6, foo() after printing the value pointed by \"mem_ptr\" frees the block. In line 23, main() tries to re-free \"mem_ptr\". You may think that in this small program, it's easy to see that \"mem_ptr\" is freed twice, right? In reality, it may be really hard to see this problem especially when multiple pointers point to the same block of memory (i.e., this is called pointer aliasing). Let's run the program and see what will happen: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o double-free double-free.c ECE2400: ~/SFU-CMPT-431/tests % ./double-free In main(): mem_ptr: address = 0xcec010, value = 10 In foo(): mem_ptr: address = 0xcec010, value = 10 *** Error in `./double-free': double free or corruption (fasttop): 0x0000000000cec010 *** ======= Backtrace: ========= /lib64/libc.so.6(+0x81429)[0x7f5564d81429] ./double-free[0x4004f8] /lib64/libc.so.6(__libc_start_main+0xf5)[0x7f5564d223d5] ./double-free[0x400525] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00600000-00601000 r--p 00000000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00601000-00602000 rw-p 00001000 00:28 190587185 /home/qtt2/SFU-CMPT-431/tests/double-free 00cec000-00d0d000 rw-p 00000000 00:00 0 [heap] 7f5560000000-7f5560021000 rw-p 00000000 00:00 0 7f5560021000-7f5564000000 ---p 00000000 00:00 0 7f5564aea000-7f5564aff000 r-xp 00000000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564aff000-7f5564cfe000 ---p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564cfe000-7f5564cff000 r--p 00014000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564cff000-7f5564d00000 rw-p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7f5564d00000-7f5564ec3000 r-xp 00000000 fd:00 148997 /usr/lib64/libc-2.17.so 7f5564ec3000-7f55650c2000 ---p 001c3000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c2000-7f55650c6000 r--p 001c2000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c6000-7f55650c8000 rw-p 001c6000 fd:00 148997 /usr/lib64/libc-2.17.so 7f55650c8000-7f55650cd000 rw-p 00000000 00:00 0 7f55650cd000-7f55650ef000 r-xp 00000000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652c6000-7f55652c9000 rw-p 00000000 00:00 0 7f55652eb000-7f55652ee000 rw-p 00000000 00:00 0 7f55652ee000-7f55652ef000 r--p 00021000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652ef000-7f55652f0000 rw-p 00022000 fd:00 148990 /usr/lib64/ld-2.17.so 7f55652f0000-7f55652f1000 rw-p 00000000 00:00 0 7ffeec44c000-7ffeec46e000 rw-p 00000000 00:00 0 [stack] 7ffeec485000-7ffeec487000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] Aborted (core dumped) Oopps, our program crashed! No worries. Our friend valgrind can help us detect what went wrong. Let's run valgrind and see what it reports. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./double-free ==23220== Memcheck, a memory error detector ==23220== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==23220== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==23220== Command: ./double-free ==23220== In main(): mem_ptr: address = 0x5202040, value = 10 In foo(): mem_ptr: address = 0x5202040, value = 10 ==23220== Invalid free() / delete / delete[] / realloc() ==23220== at 0x4C2AC7D: free (vg_replace_malloc.c:530) ==23220== by 0x4004F7: main (double-free.c:23) ==23220== Address 0x5202040 is 0 bytes inside a block of size 4 free'd ==23220== at 0x4C2AC7D: free (vg_replace_malloc.c:530) ==23220== by 0x4004EF: main (double-free.c:20) ==23220== Block was alloc'd at ==23220== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==23220== by 0x4004CA: main (double-free.c:12) ==23220== ==23220== ==23220== HEAP SUMMARY: ==23220== in use at exit: 0 bytes in 0 blocks ==23220== total heap usage: 1 allocs, 2 frees, 4 bytes allocated ==23220== ==23220== All heap blocks were freed -- no leaks are possible ==23220== ==23220== For counts of detected and suppressed errors, rerun with: -v ==23220== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0) Valgrind tells us that there was an \"invalid free()\" in line 23 of double-free.c . Thanks to Valgrind, now you know exactly what the problem is. Can you fix it on your own and re-run valgrind?","title":"2. Double free your memory"},{"location":"SFU-CMPT-431-memory-debugging/#3-invalid-memory-access","text":"Remember that C compiler does not check out-of-bounds array access. You may accidentally access some memory blocks that are not allocated. Let's consider this buggy program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 #include <stdlib.h> 2 #include <stdio.h> 3 4 int main( void ) { 5 6 const int size = 10; 7 int* mem_ptr = ( int* ) malloc( sizeof( int ) * size ); 8 9 for ( int i = 0; i <= size; i++ ) { 10 printf( \"Initializing mem_ptr[%d] ... \\n\", i ); 11 mem_ptr[i] = i; 12 } 13 14 // Print out the array 15 for ( int i = 0; i <= size; i++ ) { 16 printf( \"mem_ptr[%d] = %d\\n\", i, mem_ptr[i] ); 17 } 18 19 // Free mem_ptr 20 free(mem_ptr); 21 22 return 0; 23 } Notice that the program allocates an array of 10 \"int\" elements on the heap (in line 7). It by mistake initializes the 11th element when i == size in line 9. Then in line 15, the program tries to read that unallocated element. When you compile and run the program, you will get something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ECE2400: ~/SFU-CMPT-431/tests % gcc -Wall -g -O3 -o out-of-bound-access out-of-bound-access.c ECE2400: ~/SFU-CMPT-431/tests % ./out-of-bound-access Initializing mem_ptr[0] ... Initializing mem_ptr[1] ... Initializing mem_ptr[2] ... Initializing mem_ptr[3] ... Initializing mem_ptr[4] ... Initializing mem_ptr[5] ... Initializing mem_ptr[6] ... Initializing mem_ptr[7] ... Initializing mem_ptr[8] ... Initializing mem_ptr[9] ... Initializing mem_ptr[10] ... mem_ptr[0] = 0 mem_ptr[1] = 1 mem_ptr[2] = 2 mem_ptr[3] = 3 mem_ptr[4] = 4 mem_ptr[5] = 5 mem_ptr[6] = 6 mem_ptr[7] = 7 mem_ptr[8] = 8 mem_ptr[9] = 9 mem_ptr[10] = 10 *** Error in `./out-of-bound-access': free(): invalid next size (fast): 0x0000000001d1e010 *** ======= Backtrace: ========= /lib64/libc.so.6(+0x81429)[0x7fdf3ec46429] ./out-of-bound-access[0x400524] /lib64/libc.so.6(__libc_start_main+0xf5)[0x7fdf3ebe73d5] ./out-of-bound-access[0x400556] ======= Memory map: ======== 00400000-00401000 r-xp 00000000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 00600000-00601000 r--p 00000000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 00601000-00602000 rw-p 00001000 00:28 190587184 /home/qtt2/SFU-CMPT-431/tests/out-of-bound-access 01d1e000-01d3f000 rw-p 00000000 00:00 0 [heap] 7fdf38000000-7fdf38021000 rw-p 00000000 00:00 0 7fdf38021000-7fdf3c000000 ---p 00000000 00:00 0 7fdf3e9af000-7fdf3e9c4000 r-xp 00000000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3e9c4000-7fdf3ebc3000 ---p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc3000-7fdf3ebc4000 r--p 00014000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc4000-7fdf3ebc5000 rw-p 00015000 fd:00 1188523 /usr/lib64/libgcc_s-4.8.5-20150702.so.1 7fdf3ebc5000-7fdf3ed88000 r-xp 00000000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ed88000-7fdf3ef87000 ---p 001c3000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef87000-7fdf3ef8b000 r--p 001c2000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef8b000-7fdf3ef8d000 rw-p 001c6000 fd:00 148997 /usr/lib64/libc-2.17.so 7fdf3ef8d000-7fdf3ef92000 rw-p 00000000 00:00 0 7fdf3ef92000-7fdf3efb4000 r-xp 00000000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f18b000-7fdf3f18e000 rw-p 00000000 00:00 0 7fdf3f1b0000-7fdf3f1b3000 rw-p 00000000 00:00 0 7fdf3f1b3000-7fdf3f1b4000 r--p 00021000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f1b4000-7fdf3f1b5000 rw-p 00022000 fd:00 148990 /usr/lib64/ld-2.17.so 7fdf3f1b5000-7fdf3f1b6000 rw-p 00000000 00:00 0 7ffe872bd000-7ffe872df000 rw-p 00000000 00:00 0 [stack] 7ffe872e7000-7ffe872e9000 r-xp 00000000 00:00 0 [vdso] ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0 [vsyscall] Aborted (core dumped) The program crashed at the very end when it tried to free an unallocated memory block. Let's run it using valgrind: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ECE2400: ~/SFU-CMPT-431/tests % valgrind --leak-check=full --error-exitcode=1 ./out-of-bound-access ==31457== Memcheck, a memory error detector ==31457== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al. ==31457== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info ==31457== Command: ./out-of-bound-access ==31457== Initializing mem_ptr[0] ... Initializing mem_ptr[1] ... Initializing mem_ptr[2] ... Initializing mem_ptr[3] ... Initializing mem_ptr[4] ... Initializing mem_ptr[5] ... Initializing mem_ptr[6] ... Initializing mem_ptr[7] ... Initializing mem_ptr[8] ... Initializing mem_ptr[9] ... Initializing mem_ptr[10] ... ==31457== Invalid write of size 4 ==31457== at 0x4004E6: main (out-of-bound-access.c:11) ==31457== Address 0x5202068 is 0 bytes after a block of size 40 alloc'd ==31457== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==31457== by 0x4004D1: main (out-of-bound-access.c:7) ==31457== mem_ptr[0] = 0 mem_ptr[1] = 1 mem_ptr[2] = 2 mem_ptr[3] = 3 mem_ptr[4] = 4 mem_ptr[5] = 5 mem_ptr[6] = 6 mem_ptr[7] = 7 mem_ptr[8] = 8 mem_ptr[9] = 9 ==31457== Invalid read of size 4 ==31457== at 0x400500: main (out-of-bound-access.c:16) ==31457== Address 0x5202068 is 0 bytes after a block of size 40 alloc'd ==31457== at 0x4C29B83: malloc (vg_replace_malloc.c:299) ==31457== by 0x4004D1: main (out-of-bound-access.c:7) ==31457== mem_ptr[10] = 10 ==31457== ==31457== HEAP SUMMARY: ==31457== in use at exit: 0 bytes in 0 blocks ==31457== total heap usage: 1 allocs, 1 frees, 40 bytes allocated ==31457== ==31457== All heap blocks were freed -- no leaks are possible ==31457== ==31457== For counts of detected and suppressed errors, rerun with: -v ==31457== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0) Valgrind reported an \"Invalid write of size 4\" in line 11 and an \"Invalid read of size 4\" in line 16. They're exactly where we by mistake accessed data blocks outside our allocated array. Now, you can hopefully clearly see the bug and fix it on your own.","title":"3. Invalid memory access"},{"location":"SFU-CMPT-431-memory-debugging/#how-to-use-valgrind-in-your-pas","text":"In PAs, we provide you a make target called \"make memcheck\" that you can use to do memory check on your tests. You can do like this 1 2 3 4 5 6 7 8 9 10 11 % # go to your PA directory % cd ${HOME}/SFU-CMPT-431/<netid>/pa2-dstruct % mkdir -p build % cd build % # run memcheck on all tests % make memcheck % # run memcheck on a single test (e.g., dlist-basic-tests) % make memcheck-dlist-basic-tests % # see reports generated by Valgrind % cd memtest-logs % geany dlist-basic-tests.log &","title":"How to use valgrind in your PAs"},{"location":"SFU-CMPT-431-sec1-linux/","text":"Section 1: Linux Development Environment \u00b6 This section serves as gentle introduction to the basics of using the Linux development environment on the ecelinux machines including how to log into the machines, how to work at the Linux command line, and how to use Git version control. 1. The ecelinux Machines \u00b6 We will be using the ecelinux workstations and servers for all of the programming assignments. The ecelinux machines all run the Red Hat Enterprise Linux 7 operating system, and they all use an identical setup. Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course. 1.1. Options For Using ecelinux Machines \u00b6 directly use workstations in 314 Phillips Linux Lab log in remotely from workstations in 318 Phillips Windows Lab log in remotely from your own laptop in this discussion section, we will be logging in remotely from the workstations in the 318 Phillips Windows Lab 1.2. Using MobaXterm to Log Into the ecelinux Servers \u00b6 The first step is to log into the Windows workstation using your NetID and your standard NetID password. The second step is to start MobaXterm. From the Start menu, choose MobaXterm Educational Edition > MobaXterm Educational Edition . Then double click on ecelinux.ece.cornell.edu under Saved sessions in MobaXterm. Log in using your NetID and password. Click Yes when asked if you want to save your password. This will make it easier to open multiple terminals if you need to. All of your credentials will be deleted when you restart the workstation so there is no security concern. If you cannot log in into ecelinux , then it may be because you are either not enrolled in the course or you added the course this morning. We will be updating the access list often. 1.3. Using Multiple Terminals in MobaXterm \u00b6 It is often very useful to have multiple terminals open at the same time. From the menu, choose Sessions > ecelinux.ece.cornell.edu to create a new tab with a second terminal. Enter your NetID and you should be logged into the ecelinux servers. Now you can move back and forth between the two terminals. You can also detach a tab so you can have two terminals side-by-side. From the menu, choose Terminal > Detach . Then drag the new window all the way to the left so it fills up the left-hand side of your screen. Drag the original MobaXterm all the way to the left so it fills up the right-hand size of your screen. Now you have two terminals side-by-side, enabling you to be doing multiple things on the server at the same time. 2. ecelinux Account Setup \u00b6 The very first thing you need to do after logging into a ecelinux machine is source the course setup script. This will ensure your environment is setup with everything you need for working on the programming assignments. Enter the following command on the command line: 1 % source setup-SFU-CMPT-431.sh Note that you do not need to enter % character. In a tutorial like this, the % simply indicates what you should type at the command line. You should now see ECE 2400 in your prompt which means your environment is setup for the course. It can be tedious to always remember to source the course setup script. You can also use auto setup which will automatically source the course setup for you when you log in. Note that if the environment for ECE 2400 conflicts with the environment required by a different course then you will need to manually source the setup script when you are working on this course. Enter the following command on the command line to use auto setup: 1 % source setup-SFU-CMPT-431.sh --enable-auto-setup Now quit MobaXterm, restart MobaXterm, and log back into the ecelinux server. You should see ECE 2400 in the prompt meaning your environment is automatically setup for the course. If at anytime you need to disable auto setup you can use the following command: 1 % source setup-SFU-CMPT-431.sh --disable-auto-setup Now that we have source the course setup script we can start to explore the Linux command line. 3. Linux Command Line \u00b6 We will using the ecelinux workstations and servers which run the Red Hat Enterprise Linux 7 operating system for all of the programming assignments. The heart of the Linux operating system is the Linux command line. This is a text-based console where you can enter commands to interact with the operating system. 3.1 Hello World \u00b6 We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the echo command. The echo command simply \"echoes\" its input to the console. 1 % echo \"Hello, World\" The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on. Again, note that you do not need to enter % character. To-Do On Your Own Experiment with using the echo command to display different messages. 3.2. Manual Pages \u00b6 You can learn more about any Linux command by using the man command. Try using this to learn more about the echo command. 1 % man echo You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the manual. 3.3. Create, View, and List Files \u00b6 We can use the echo command and a feature called command output redirection to create simple text files. Command output redirection is discussed more in the full tutorial. Command output redirection uses the > operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named SFU-CMPT-431-sec1.txt that simply contains the text \"Computer Systems Programming\". 1 % echo \"Computer Systems Programming\" > SFU-CMPT-431-sec1.txt We can use the cat command to quickly display the contents of a file. 1 % cat SFU-CMPT-431-sec1.txt For larger files, cat will output the entire file to the console so it may be hard to read the file as it streams past. We can use the less command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the file. 1 % less SFU-CMPT-431-sec1.txt You can use the ls command to list the filenames of the files you have created. 1 % ls We can provide command line options to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the -l (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file. To-Do On Your Own Create a new file named SFU-CMPT-431-sec1-layer3.txt which contains the third layer in the computing systems stack (i.e., programming language). Use cat and less to verify the file contents. 3.4. Create, Change, and List Directories \u00b6 Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server that you can use to work on the programming assignments and store your files. You can use the pwd command to print the directory in which you are currently working, which is known as the current working directory. 1 2 % pwd /home/netid You should see output similar to what is shown above, but instead of netid it should show your actual NetID. The pwd command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named home that contains a directory named netid . This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named SFU-CMPT-431 within your home directory. 1 % mkdir SFU-CMPT-431 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created SFU-CMPT-431 directory, before displaying the current working directory with the pwd command. 1 2 3 % cd SFU-CMPT-431 % pwd /home/netid/SFU-CMPT-431 Use the mkdir , cd , and pwd commands to make another directory. 1 2 3 4 % mkdir sec1 % cd sec1 % pwd /home/netid/SFU-CMPT-431/sec1 We sometimes say that sec1 is a subdirectory or a child directory of the SFU-CMPT-431 directory. We might also say that the ece2400 directory is the parent directory of the sec1 directory. Use the following command to create a new file in this child directory. 1 2 3 4 % cd /home/netid/SFU-CMPT-431/sec1 % echo \"Computer Systems Programming\" > SFU-CMPT-431-sec1.txt % mkdir dirA % ls You can use the tree command to visualize the directory layout and where files are located: 1 2 % cd ~/SFU-CMPT-431 % tree Note that the tilde character ( ~ ) is a shortcut which always refers to your home directory. There are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. 1 2 3 4 % cd ~/SFU-CMPT-431/sec1 % cd .. % cd .. % pwd To-Do On Your Own Experiment with creating additional directories and files within the SFU-CMPT-431/sec1 subdirectory. Try using the tree command to display your newly created directory hierarchy. 3.5. Copy, Move, and Remove Files and Directories \u00b6 We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. 1 2 3 4 % cd ~/SFU-CMPT-431/sec1 % cp SFU-CMPT-431-sec1.txt ece2400-sec1-a.txt % cp SFU-CMPT-431-sec1.txt ece2400-sec1-b.txt % ls Instead of copying we can also move a file with the mv command: 1 2 3 % cd ~/SFU-CMPT-431/sec1 % mv SFU-CMPT-431-sec1.txt ece2400-sec1-c.txt % ls Finally, we can use the rm command to remove files. 1 2 3 % cd ~/SFU-CMPT-431/sec1 % ls % rm SFU-CMPT-431-sec1-a.txt To-Do On Your Own Creating additional directories and files within the SFU-CMPT-431/sec1 subdirectory, and then use the cp , mv , and rm commands to copy, move, and remove the newly created directories and files. Use the ls and tree commands to display your file and directory organization. 3.6. Text Editors \u00b6 Students are free to use any text editor they want. We recommend using either Micro or Geany. You can start Micro like this: 1 % micro SFU-CMPT-431-sec1-b.txt Micro is a lightweight text-based text editor. Use Ctrl-G to learn more about the keyboard shortcuts you can use to in Micro. You can start Geany like this: 1 % geany SFU-CMPT-431-sec1-b.txt & Geany is a graphical-based text editor. Notice the & character at the end of the command line. This indicates that Linux should run Geany in the background meaning you can still work at the command line while Geany is running in a different window. To-Do On Your Own Try editing the SFU-CMPT-431-sec1.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . When you are finished go ahead and delete the sec1 directory to keep things tidy. 1 % rm -rf ~/SFU-CMPT-431/sec1 4. GitHub Account Setup \u00b6 We will be using GitHub for centralized repository hosting. You can check to see if you have a GitHub account on github.com using this link: https://github.com/githubid where githubid is your GitHub username on github.com . If the above link does not work, then you do not have an GitHub account on github.com . NOTE: We are using github.com not the Cornell hosted GitHub! You will need to create one here: https://github.com/join Your NetID makes a great GitHub username on github.com . Be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Please also consider uploading a profile photo to GitHub; it makes it more fun to interact on GitHub if we all know what each other look like. Go to the following page and enter your first and last name in the Name field, and then consider uploading a profile photo. https://github.com/settings/profile Once you have a GitHub ID, please fill out the following online so the instructors know the mapping from NetID to GitHub ID: http://www.csl.cornell.edu/courses/SFU-CMPT-431/signup Before you can begin using GitHub, you need to create an SSH key pair on an ecelinux machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. The course setup script takes care of creating an SSH key pair which you can use. View the contents of your public key using the following commands: 1 % cat ~/.ssh/SFU-CMPT-431-github.pub Use the following page to upload the public key to GitHub: https://github.com/settings/ssh Click on New SSH Key , and then cut-and-paste the public key you displayed using cat into the key textbox. Give the key the title SFU-CMPT-431-github . Then click Add SSH key . To test things out try the following command: 1 % ssh -T git@github.com You may see a warning about the authenticity of the host. Don\u2019t worry, this is supposed to happen the first time you access GitHub using your new key. Just enter yes . The GitHub server should output some text including your GitHub ID. Verify that the GitHub ID is correct, and then you should be all set. 5. Git Version Control System \u00b6 In this course, we will be using Git as our revision control and source code management system. Git will enable us to adopt an agile hardware development methodology so you (and your group) can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments. 5.1. Fork and Clone a Repo from GitHub \u00b6 Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-SFU-CMPT-431/ece2400-sec1 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/SFU-CMPT-431-sec1 Where githubid is your GitHubID. Now let's clone your new repo to the ecelinux machine. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:githubid/SFU-CMPT-431-sec1 sec1 % cd sec1 % cat README.md Where githubid is your GitHubID. 5.2. Adding and Committing Files to Local Repository \u00b6 Now let's add some new files to the repository. Use your favorite text editor (e.g., Micro, Geany) to create a file named warm-colors.txt with three warm colors: 1 2 3 red orange yellow Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. 1 2 3 blue green purple Now let's add these files to our repository. First use the git status command to check on the status of the repository. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git status You should see that git has noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area so it now knows it should keep track of them: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec1 % git add warm-colors.txt % git add cool-colors.txt % git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git commit -m \"add some colors\" To-Do On Your Own Try adding cyan to the cool-colors.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . Then use git status , git add , and git commit to add these changes to local repository. 5.3. Pushing Files to GitHub \u00b6 Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git push Now go to the repository page using the GitHub web interface and verify that there are two new files. https://github.com/githubid/SFU-CMPT-431-sec1 To-Do On Your Own Try adding mustard to the warm-colors.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . Then use git status , git add , and git commit to add these changes to local repository, and then use git push to push these changes up to GitHub. View the changes using the GitHub web interface. 5.4. Pulling Files from GitHub \u00b6 Let's try making a change to this repository through the GitHub web interface. https://github.com/githubid/SFU-CMPT-431-sec1 Click on Create new file . Name the file languages.txt and add a list of programming languages: 1 2 3 4 5 C C++ Python MATLAB Java Now click Commit new file . Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec1 % git pull % cat languages.txt This will be the basic GitHub workflow were students pull and push code between GitHub and the ecelinux machines. To-Do On Your Own Try editing a file using the GitHub web interface. Click on the warm-colors.txt file and then click on the pencil in the right-hand corner to edit this text file. Add another warm color. Click Commit changes . Then pull these changes to the local repository on the ecelinux server and verify that your new warm color is included.","title":"Section 1: Linux Development Environment"},{"location":"SFU-CMPT-431-sec1-linux/#section-1-linux-development-environment","text":"This section serves as gentle introduction to the basics of using the Linux development environment on the ecelinux machines including how to log into the machines, how to work at the Linux command line, and how to use Git version control.","title":"Section 1: Linux Development Environment"},{"location":"SFU-CMPT-431-sec1-linux/#1-the-ecelinux-machines","text":"We will be using the ecelinux workstations and servers for all of the programming assignments. The ecelinux machines all run the Red Hat Enterprise Linux 7 operating system, and they all use an identical setup. Linux is the operating system of choice for both cloud and IoT systems, so becoming familiar with Linux will pay dividends beyond just this course.","title":"1. The ecelinux Machines"},{"location":"SFU-CMPT-431-sec1-linux/#11-options-for-using-ecelinux-machines","text":"directly use workstations in 314 Phillips Linux Lab log in remotely from workstations in 318 Phillips Windows Lab log in remotely from your own laptop in this discussion section, we will be logging in remotely from the workstations in the 318 Phillips Windows Lab","title":"1.1. Options For Using ecelinux Machines"},{"location":"SFU-CMPT-431-sec1-linux/#12-using-mobaxterm-to-log-into-the-ecelinux-servers","text":"The first step is to log into the Windows workstation using your NetID and your standard NetID password. The second step is to start MobaXterm. From the Start menu, choose MobaXterm Educational Edition > MobaXterm Educational Edition . Then double click on ecelinux.ece.cornell.edu under Saved sessions in MobaXterm. Log in using your NetID and password. Click Yes when asked if you want to save your password. This will make it easier to open multiple terminals if you need to. All of your credentials will be deleted when you restart the workstation so there is no security concern. If you cannot log in into ecelinux , then it may be because you are either not enrolled in the course or you added the course this morning. We will be updating the access list often.","title":"1.2. Using MobaXterm to Log Into the ecelinux Servers"},{"location":"SFU-CMPT-431-sec1-linux/#13-using-multiple-terminals-in-mobaxterm","text":"It is often very useful to have multiple terminals open at the same time. From the menu, choose Sessions > ecelinux.ece.cornell.edu to create a new tab with a second terminal. Enter your NetID and you should be logged into the ecelinux servers. Now you can move back and forth between the two terminals. You can also detach a tab so you can have two terminals side-by-side. From the menu, choose Terminal > Detach . Then drag the new window all the way to the left so it fills up the left-hand side of your screen. Drag the original MobaXterm all the way to the left so it fills up the right-hand size of your screen. Now you have two terminals side-by-side, enabling you to be doing multiple things on the server at the same time.","title":"1.3. Using Multiple Terminals in MobaXterm"},{"location":"SFU-CMPT-431-sec1-linux/#2-ecelinux-account-setup","text":"The very first thing you need to do after logging into a ecelinux machine is source the course setup script. This will ensure your environment is setup with everything you need for working on the programming assignments. Enter the following command on the command line: 1 % source setup-SFU-CMPT-431.sh Note that you do not need to enter % character. In a tutorial like this, the % simply indicates what you should type at the command line. You should now see ECE 2400 in your prompt which means your environment is setup for the course. It can be tedious to always remember to source the course setup script. You can also use auto setup which will automatically source the course setup for you when you log in. Note that if the environment for ECE 2400 conflicts with the environment required by a different course then you will need to manually source the setup script when you are working on this course. Enter the following command on the command line to use auto setup: 1 % source setup-SFU-CMPT-431.sh --enable-auto-setup Now quit MobaXterm, restart MobaXterm, and log back into the ecelinux server. You should see ECE 2400 in the prompt meaning your environment is automatically setup for the course. If at anytime you need to disable auto setup you can use the following command: 1 % source setup-SFU-CMPT-431.sh --disable-auto-setup Now that we have source the course setup script we can start to explore the Linux command line.","title":"2. ecelinux Account Setup"},{"location":"SFU-CMPT-431-sec1-linux/#3-linux-command-line","text":"We will using the ecelinux workstations and servers which run the Red Hat Enterprise Linux 7 operating system for all of the programming assignments. The heart of the Linux operating system is the Linux command line. This is a text-based console where you can enter commands to interact with the operating system.","title":"3. Linux Command Line"},{"location":"SFU-CMPT-431-sec1-linux/#31-hello-world","text":"We begin with the ubiquitous \"Hello, World\" example. To display the message \"Hello, World\" we will use the echo command. The echo command simply \"echoes\" its input to the console. 1 % echo \"Hello, World\" The string we provide to the echo command is called a command line argument . We use command line arguments to tell commands what they should operate on. Again, note that you do not need to enter % character. To-Do On Your Own Experiment with using the echo command to display different messages.","title":"3.1 Hello World"},{"location":"SFU-CMPT-431-sec1-linux/#32-manual-pages","text":"You can learn more about any Linux command by using the man command. Try using this to learn more about the echo command. 1 % man echo You can use the up/down keys to scroll the manual one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the manual.","title":"3.2. Manual Pages"},{"location":"SFU-CMPT-431-sec1-linux/#33-create-view-and-list-files","text":"We can use the echo command and a feature called command output redirection to create simple text files. Command output redirection is discussed more in the full tutorial. Command output redirection uses the > operator to take the output from one command and \"redirect\" it to a file. The following commands will create a new file named SFU-CMPT-431-sec1.txt that simply contains the text \"Computer Systems Programming\". 1 % echo \"Computer Systems Programming\" > SFU-CMPT-431-sec1.txt We can use the cat command to quickly display the contents of a file. 1 % cat SFU-CMPT-431-sec1.txt For larger files, cat will output the entire file to the console so it may be hard to read the file as it streams past. We can use the less command to show one screen-full of text at a time. You can use the up/down keys to scroll the file one line at a time, the space bar to scroll down one page at a time, and the q key to quit viewing the file. 1 % less SFU-CMPT-431-sec1.txt You can use the ls command to list the filenames of the files you have created. 1 % ls We can provide command line options to the ls command to modify the command\u2019s behavior. For example, we can use the -1 (i.e., a dash followed by the number one) command line option to list one file per line, and we can we can use the -l (i.e., a dash followed by the letter l) command line option to provide a longer listing with more information about each file. To-Do On Your Own Create a new file named SFU-CMPT-431-sec1-layer3.txt which contains the third layer in the computing systems stack (i.e., programming language). Use cat and less to verify the file contents.","title":"3.3. Create, View, and List Files"},{"location":"SFU-CMPT-431-sec1-linux/#34-create-change-and-list-directories","text":"Obviously, having all files in a single location would be hard to manage effectively. We can use directories (also called folders) to logically organize our files, just like one can use physical folders to organize physical pieces of paper. The mechanism for organizing files and directories is called the file system. When you first login to an ecelinux machine, you will be in your home directory. This is your own private space on the server that you can use to work on the programming assignments and store your files. You can use the pwd command to print the directory in which you are currently working, which is known as the current working directory. 1 2 % pwd /home/netid You should see output similar to what is shown above, but instead of netid it should show your actual NetID. The pwd command shows a directory path. A directory path is a list of nested directory names; it describes a \"path\" to get to a specific file or directory. So the above path indicates that there is a toplevel directory named home that contains a directory named netid . This is the directory path to your home directory. As an aside, notice that Linux uses a forward slash ( / ) to separate directories, while Windows uses a back slash ( \\ ) for the same purpose. We can use the mkdir command to make new directories. The following command will make a new directory named SFU-CMPT-431 within your home directory. 1 % mkdir SFU-CMPT-431 We can use the cd command to change our current working directory. The following command will change the current working directory to be the newly created SFU-CMPT-431 directory, before displaying the current working directory with the pwd command. 1 2 3 % cd SFU-CMPT-431 % pwd /home/netid/SFU-CMPT-431 Use the mkdir , cd , and pwd commands to make another directory. 1 2 3 4 % mkdir sec1 % cd sec1 % pwd /home/netid/SFU-CMPT-431/sec1 We sometimes say that sec1 is a subdirectory or a child directory of the SFU-CMPT-431 directory. We might also say that the ece2400 directory is the parent directory of the sec1 directory. Use the following command to create a new file in this child directory. 1 2 3 4 % cd /home/netid/SFU-CMPT-431/sec1 % echo \"Computer Systems Programming\" > SFU-CMPT-431-sec1.txt % mkdir dirA % ls You can use the tree command to visualize the directory layout and where files are located: 1 2 % cd ~/SFU-CMPT-431 % tree Note that the tilde character ( ~ ) is a shortcut which always refers to your home directory. There are a few other very useful shortcuts. You can use a single dot ( . ) to refer to the current working directory, and you can use a double dot ( .. ) to refer to the parent directory of the current working directory. 1 2 3 4 % cd ~/SFU-CMPT-431/sec1 % cd .. % cd .. % pwd To-Do On Your Own Experiment with creating additional directories and files within the SFU-CMPT-431/sec1 subdirectory. Try using the tree command to display your newly created directory hierarchy.","title":"3.4. Create, Change, and List Directories"},{"location":"SFU-CMPT-431-sec1-linux/#35-copy-move-and-remove-files-and-directories","text":"We can use the cp command to copy files. The first argument is the name of the file you want to copy, and the second argument is the new name to give to the copy. The following commands will make two copies of the files we created in the previous section. 1 2 3 4 % cd ~/SFU-CMPT-431/sec1 % cp SFU-CMPT-431-sec1.txt ece2400-sec1-a.txt % cp SFU-CMPT-431-sec1.txt ece2400-sec1-b.txt % ls Instead of copying we can also move a file with the mv command: 1 2 3 % cd ~/SFU-CMPT-431/sec1 % mv SFU-CMPT-431-sec1.txt ece2400-sec1-c.txt % ls Finally, we can use the rm command to remove files. 1 2 3 % cd ~/SFU-CMPT-431/sec1 % ls % rm SFU-CMPT-431-sec1-a.txt To-Do On Your Own Creating additional directories and files within the SFU-CMPT-431/sec1 subdirectory, and then use the cp , mv , and rm commands to copy, move, and remove the newly created directories and files. Use the ls and tree commands to display your file and directory organization.","title":"3.5. Copy, Move, and Remove Files and Directories"},{"location":"SFU-CMPT-431-sec1-linux/#36-text-editors","text":"Students are free to use any text editor they want. We recommend using either Micro or Geany. You can start Micro like this: 1 % micro SFU-CMPT-431-sec1-b.txt Micro is a lightweight text-based text editor. Use Ctrl-G to learn more about the keyboard shortcuts you can use to in Micro. You can start Geany like this: 1 % geany SFU-CMPT-431-sec1-b.txt & Geany is a graphical-based text editor. Notice the & character at the end of the command line. This indicates that Linux should run Geany in the background meaning you can still work at the command line while Geany is running in a different window. To-Do On Your Own Try editing the SFU-CMPT-431-sec1.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . When you are finished go ahead and delete the sec1 directory to keep things tidy. 1 % rm -rf ~/SFU-CMPT-431/sec1","title":"3.6. Text Editors"},{"location":"SFU-CMPT-431-sec1-linux/#4-github-account-setup","text":"We will be using GitHub for centralized repository hosting. You can check to see if you have a GitHub account on github.com using this link: https://github.com/githubid where githubid is your GitHub username on github.com . If the above link does not work, then you do not have an GitHub account on github.com . NOTE: We are using github.com not the Cornell hosted GitHub! You will need to create one here: https://github.com/join Your NetID makes a great GitHub username on github.com . Be sure to use your Cornell University email address. Once your account is setup, please make sure you set your full name so we can know who you are on GitHub. Please also consider uploading a profile photo to GitHub; it makes it more fun to interact on GitHub if we all know what each other look like. Go to the following page and enter your first and last name in the Name field, and then consider uploading a profile photo. https://github.com/settings/profile Once you have a GitHub ID, please fill out the following online so the instructors know the mapping from NetID to GitHub ID: http://www.csl.cornell.edu/courses/SFU-CMPT-431/signup Before you can begin using GitHub, you need to create an SSH key pair on an ecelinux machine and upload the corresponding SSH public key to GitHub. GitHub uses these keys for authentication. The course setup script takes care of creating an SSH key pair which you can use. View the contents of your public key using the following commands: 1 % cat ~/.ssh/SFU-CMPT-431-github.pub Use the following page to upload the public key to GitHub: https://github.com/settings/ssh Click on New SSH Key , and then cut-and-paste the public key you displayed using cat into the key textbox. Give the key the title SFU-CMPT-431-github . Then click Add SSH key . To test things out try the following command: 1 % ssh -T git@github.com You may see a warning about the authenticity of the host. Don\u2019t worry, this is supposed to happen the first time you access GitHub using your new key. Just enter yes . The GitHub server should output some text including your GitHub ID. Verify that the GitHub ID is correct, and then you should be all set.","title":"4. GitHub Account Setup"},{"location":"SFU-CMPT-431-sec1-linux/#5-git-version-control-system","text":"In this course, we will be using Git as our revision control and source code management system. Git will enable us to adopt an agile hardware development methodology so you (and your group) can rapidly collaborate and iterate on the design, verification, and evaluation of the assignments.","title":"5. Git Version Control System"},{"location":"SFU-CMPT-431-sec1-linux/#51-fork-and-clone-a-repo-from-github","text":"Fork'ing a repo means making a copy of that repo for your own local use. We won't actually be forking repos for the programming assignments, but it is an easy way for you to grab some example code for the discussion section. Go to the example repo here: https://github.com/cornell-SFU-CMPT-431/ece2400-sec1 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/SFU-CMPT-431-sec1 Where githubid is your GitHubID. Now let's clone your new repo to the ecelinux machine. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:githubid/SFU-CMPT-431-sec1 sec1 % cd sec1 % cat README.md Where githubid is your GitHubID.","title":"5.1. Fork and Clone a Repo from GitHub"},{"location":"SFU-CMPT-431-sec1-linux/#52-adding-and-committing-files-to-local-repository","text":"Now let's add some new files to the repository. Use your favorite text editor (e.g., Micro, Geany) to create a file named warm-colors.txt with three warm colors: 1 2 3 red orange yellow Now use your favorite text editor again to create a file named cool-colors.txt with three cool colors. 1 2 3 blue green purple Now let's add these files to our repository. First use the git status command to check on the status of the repository. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git status You should see that git has noticed two \"untracked files\" which are in the working directory but are not currently being tracked by git. Let's \"add\" these two files to git's \"staging\" area so it now knows it should keep track of them: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec1 % git add warm-colors.txt % git add cool-colors.txt % git status The status of these two files have changed. Git reports that both of the new files are ready to be committed. Let's go ahead and commit these changes into your local repository. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git commit -m \"add some colors\" To-Do On Your Own Try adding cyan to the cool-colors.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . Then use git status , git add , and git commit to add these changes to local repository.","title":"5.2. Adding and Committing Files to Local Repository"},{"location":"SFU-CMPT-431-sec1-linux/#53-pushing-files-to-github","text":"Note that nothing has happened on GitHub yet. GitHub does not know anything about these local changes. We need to explicitly \"push\" our new commits up to GitHub like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec1 % git push Now go to the repository page using the GitHub web interface and verify that there are two new files. https://github.com/githubid/SFU-CMPT-431-sec1 To-Do On Your Own Try adding mustard to the warm-colors.txt file you created earlier using either Micro or Geany. Save the file and then view your changes from the command line using cat . Then use git status , git add , and git commit to add these changes to local repository, and then use git push to push these changes up to GitHub. View the changes using the GitHub web interface.","title":"5.3. Pushing Files to GitHub"},{"location":"SFU-CMPT-431-sec1-linux/#54-pulling-files-from-github","text":"Let's try making a change to this repository through the GitHub web interface. https://github.com/githubid/SFU-CMPT-431-sec1 Click on Create new file . Name the file languages.txt and add a list of programming languages: 1 2 3 4 5 C C++ Python MATLAB Java Now click Commit new file . Verify that there is a new file in the repo using the GitHub web interface. Now let's \"pull\" these new changes from GitHub to your local repo on ecelinux : 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec1 % git pull % cat languages.txt This will be the basic GitHub workflow were students pull and push code between GitHub and the ecelinux machines. To-Do On Your Own Try editing a file using the GitHub web interface. Click on the warm-colors.txt file and then click on the pencil in the right-hand corner to edit this text file. Add another warm color. Click Commit changes . Then pull these changes to the local repository on the ecelinux server and verify that your new warm color is included.","title":"5.4. Pulling Files from GitHub"},{"location":"SFU-CMPT-431-sec2-c-basics/","text":"Section 2: Compiling and Running C Programs \u00b6 This section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines. 1. The ecelinux Machines \u00b6 Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt Now clone the GitHub repo we will be using in this section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec2 sec2 % cd sec2 % cat README.md 2. Using Online Tools to Explore C Programs \u00b6 In this section, we will explore to online tools that can be useful when exploring C programs. The first is Repl.it which enables us to write, compile, and run C programs in the cloud, and the second is Compiler Explore which enables us to compile C programs and view the corresponding machine instructions in the cloud. 2.1. Repl.it \u00b6 Repl.it is a free online service which supports writing, compiling, and executing C/C++ programs completely online in your browser. It will enable us to quickly explore small C/C++ code snippets. Start a browser and go to https://Repl.it . You can use Repl.it without an account. You can always create an account later. Click new repl in the upper right-hand corner. In the Search for a language drop-down choose C and the click Create repl . You will see a default program. Replace this default program with the following program inspired by today's lecture. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } Click run . This will compile and execute your C program in the cloud and then display the output on the right. To-Do On Your Own Change the value of b to 15. Recompile and execute your C program. Is the result what you expect? Modify the avg function to find the average of three values instead of just two. Modify the main function to properly call your updated function and verify it calculates the average correctly. We will be using Repl.it throughout the course. We strongly encourage students to experiment with Repl.it frequently. The best way to truly understand computer systems programming with C and C++ is to actually write programs, and the easiest way to write C and C++ programs is to just use Repl.it! 2.2. Compiler Explorer \u00b6 Compiler Explore is a free online service that compiles C programs to machine instructions and then displays these machine instructions for you to inspect completely online in your browser. It will enable us to quickly explore the connection between C and C++ code and the low-level machine instructions actually executed by the computer system. Start a browser and go to https://godbolt.org . You will see a default code snippet. Replace this code with the following code inspired by today's lecture. 1 2 3 4 5 int avg( int x, int y ) { int sum = x + y; return sum / 2; } Compiler Explore will automatically display the corresponding machine instructions on the right. It color codes C code on the left to match which exact machine instructions are produced by that C code on the right. You can right click on an instruction and select View opcode doc to learn more about what each instruction does. You can also choose from many different compilers targeting many different instruction set architectures (ISAs). Here are three different compiler/ISAs you might want to experiment with: x86-64 clang 8.0.0 : This is similar to the compiler on ecelinux MIPS gcc 5.4 (el) : This is similar to what is used in ECE 2400 RISCV-V rv32gc clang : This is similar to what is used in ECE 2400 Go ahead and choose x86-64. Notice that even though the C source code uses the integer division operator there is no division instruction on the right. This is because the compiler is smart enough to figure out that dividing by 2 is the same as shifting to the right by one bit. In the upper-right corner you will either see Compiler options or -O3 . This is where you can enter command line options that are passed to the compiler. The command line option -O3 tells the compiler to apply as many optimizations as it can. Experiment with either entering -O3 or deleting -O3 to observe the difference in the resulting machine instructions. Notice that without -O3 the compiler will generate many more instructions, and also notice that it now is using a division instruction ( idiv ). The unoptimized code would execute far slower than the optimized code. To-Do On Your Own Copy-and-paste the three-input average program you developed earlier into Compiler Explore. Inspect the corresponding machine instructions for all three compiler/ISA options mentioned above with and without optimizations. 3. C Preprocessor \u00b6 Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocessor is not really part of the C programming language. The C preprocessor simply manipulates the plain text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. The best way to understand the C preprocessor is actually to use it to preprocess plain text files as opposed to C source files. Assume we wish to create a plain text file which includes both warm and cool colors. We could simply copy-and-paste our lists from warm-colors.txt and cool-colors.txt , but this would be redundant and difficult to maintain if we wanted to add a new warm or cool color. We can instead use the C preprocessor to include the contents of one text file in another text file. Use Micro (or Geany) to create a new file named colors-in.txt like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % micro colors-in.txt Put the following content into this file: 1 2 #include \"warm-colors.txt\" #include \"cool-colors.txt\" Recall that you can save a file from Micro using Ctrl-S and you can quit using Ctrl-Q. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. The #include directive specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). Now we can use the C preprocessor ( cpp ) to preprocess the -in.txt files into a final text file that contains both the warm and cool colors. 1 % cd ${HOME}/SFU-CMPT-431/sec2 % cpp -o colors.txt colors-in.txt % cat colors.txt The -o command line option is used to specify the name of the output file. The content of the colors.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 \"colors-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 31 \"<command-line>\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4 # 32 \"<command-line>\" 2 # 1 \"colors-in.txt\" # 1 \"warm-colors.txt\" 1 red orange yellow # 2 \"colors-in.txt\" 2 # 1 \"cool-colors.txt\" 1 blue green purple # 2 \"colors-in.txt\" 2 The C preprocessor has included all of the colors in a single output file, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. We can tell cpp to not include this extra metadata with the -P command line option. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor earlier in this section when we included the stdio.h header file which includes the declaration of the printf function. Let's now modify colors-in.txt to include each file three times: 1 2 3 4 5 6 #include \"warm-colors.txt\" #include \"warm-colors.txt\" #include \"warm-colors.txt\" #include \"cool-colors.txt\" #include \"cool-colors.txt\" #include \"cool-colors.txt\" Rerun the C preprocessor and verify that the warm and cool colors are included three times. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt While this is fine for plain text files, we need to be very careful about including the same C code multiple times when we are developing our C programs. If the compiler sees the same function defined multiple times it will cause a syntax error. More modern programming languages have built-in features to ensure code is only included a single time regardless, but in C we are forced to use the C preprocessor to ensure code is only included once. We will use a technique called include guards . An include guard will ensure that the contents of a given file is only inserted into the output file once, even if we include it multiple times. For example, modify warm-colors.txt using Micro (or Geany) as follows: 1 2 3 4 5 6 #ifndef SEC2_WARM_COLORS_TXT #define SEC2_WARM_COLORS_TXT red orange yellow #endif The #ifndef directive is a conditional which will only include the content after the directive if the given preprocessor macro is defined. The #define directive \"defines\" the given preprocessor macro. So these directives essentially check to see if WARM_COLORS_TXT is defined and if not it will include the text in the file ... and also define WARM_COLORS_TXT . If we try and include this same file again then WARM_COLORS_TXT will already be defined and we will skip over the contents of the file. Modify cool-colors.txt as follows: 1 2 3 4 5 6 #ifndef SEC2_COOL_COLORS_TXT #define SEC2_COOL_COLORS_TXT blue green purple #endif Rerun the C preprocessor and you will see that the colors are only included once because of the include guards. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt The actual macro name you use for the include guard doesn't matter as long as it is unique across all files. We usually use a variation of the filename to ensure unique include guard macros. To-Do On Your Own Change the name of the macro used in both warm-colors.txt and cool-colors.txt to be COLORS_TXT . This means both files will be using the same macro name for their include guards. Rerun the C preprocessor. Try switching the order you include the files in colors.txt (e.g., include the cool colors first, and then include the warm colors). Can you explain what is going on? 4. Compiling and Running a Single-File C Program \u00b6 Now that we have explored how to use the C preprocessor for file inclusion and include guards, we will can turn out attention to writing C programs. We will begin by writing a single-file C program to calculate the average of two integers. Our goal is to reproduce what we did with Repl.it and Compiler Explorer, but by using various command line tools on the ecelinux machines. Edit the avg-sfile.c code to include an appropriate implementation of the avg function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } We use a compiler to compiler the C source code into an executable binary (i.e., the actual bits) that the machine can understand. In this course we will be using the GNU C compiler ( gcc ). Let's go ahead and give this a try: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-sfile avg-sfile.c % ls The gcc command takes as input the C source file to compile and the command line option -o is used to specify the output exectutable binary (i.e., the file with the machine instructions). We also use the -Wall command line option to report all warnings. Note that gcc automatically takes care of running the C preprocessor for us. After running the gcc command you should see a new avg-sfile file in the directory. We can execute this binary by simply calling it as any other Linux command. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % ./avg-sfile Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable binary named avg-sfile which is located in the current working directory. Repl.it is basically doing these same steps just in the cloud. It can be tedious to to have to carefully enter the correct commands on the command line every time we want to compile a C source file into an executable binary. In the next section, we will explore using a build framework to automate the process of building our C programs. The process of executing the avg-sfile executable and verifying its output is called ad-hoc testing . It is ad-hoc because there is no systematic and automatic way to run and verify tests. In the next section, we will explore using a test framework to automate the process of testing our C programs. Now let's examine the machine instructions using the objdump command. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % objdump -dC avg-sfile | less The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find how many machine instructions are used to implement the avg function. Compiler Explore is basically doing these same steps just in the cloud. Recall what you learned from experimenting with Compiler Explore earlier in this section. Does it seem like the compiler generated optimized code or unoptimized code? You can exit less by pressing the q key. Let's recompile our program with optimizations. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -O3 -o avg-sfile avg-sfile.c % objdump -dC avg-sfile | less Now how many machine instructions are used to implement the avg function? To-Do On Your Own Copy-and-paste the three-input average program you developed earlier into avg-sfile.c . Recompile this program using gcc , and then execute this program from the command line. Verify that it produces the expected output. Inspect the corresponding machine instructions with and without optimizations using objdump . 5. Compiling and Running a Multi-File C Program \u00b6 Real C programs are almost never contained in a single file. They require many files which must be individually compiled and then linked together. Linking is the process of merging together different binary files each with its own set of machine instructions. To illustrate this process we will break our avg-sfile.c source file into two files: avg.c will contain the avg function, and avg-mfile.c will contain the main function. We will compile each of these files into its own object file and then link these object files into a complete executable binary. Here is a figure illustrating the compiler and linker flow. Go ahead and use Micro (or Geany) to create the avg.c file: 1 2 3 4 5 6 7 #include \"avg.h\" int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } And now create the avg-mfile.c file: 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> #include \"avg.h\" int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } We will use gcc compile the avg.c source file into the avg.o object file, and we will also use gcc to compile the avg-mfile.c source file into the avg-mfile.o object file. Finally, we can use gcc to link both object files along with the pre-compiled C standard library and any startup code to produce an executable binary. We will also need a header file named avg.h . Header files are the key to multi-file C programs. The avg-mfile.c source file needs to call the avg function, but the avg function is in a different source file. When we compile the avg-mfile.c source file, how will the compiler know that the avg function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the avg function takes, so it can perform type checking? The avg-mfile.c source file cannot directly include avg.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell avg-mfile.c the avg function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the avg function implementation . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition is linked together into the executable binary. Create a header file for avg.c named avg.h with the following contents. 1 2 3 4 5 6 #ifndef SEC2_AVG_H #define SEC2_AVG_H int avg ( int x , int y ); #endif Notice the include guards implemented using the C preprocessor. Let's go ahead and compile avg.c and avg-mfile.c into their corresponding object files: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -c -o avg.o avg.c % gcc -Wall -c -o avg-mfile.o avg-mfile.c We use the -c command line option to indicate that gcc should create an object file as opposed to a complete executable binary. An object file is just a piece of machine instructions. We cannot actually execute an object file; we need to link multiple object files together to create a complete executable binary. We usually use the .o filename extension to indicate that these files are object files. Let's use objdump to look inside each of these object files. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % objdump -dC avg.o % objdump -dC avg-mfile.o You should be able to see that each object file only contains a few machine instructions. The avg.o object file only contains machine instructions that correspond to the avg function, while the avg-mfile.o object file only contains machine instructions that correspond to the main function. Let's link these two object files together to create a complete executable binary that we can actually run. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-mfile avg.o avg-mfile.o % objdump -dC avg-mfile Notice that the complete executable binary contains all of the machine instructions for both the avg and main functions along with a bunch of additional system-level code (e.g., for the printf function). Let's go ahead and run the executable binary. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % ./avg-mfile We can simplify this process and do the compilation and linking in a single step by specifying multiple C source files on a single command line. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-mfile avg.c avg-mfile.c % ./avg-mfile This of course begs the question. If we can compile a project with multiple files simply by specifying all of the files on the command line, then why did we learn about how to: (1) compile each file individually into an object file; and (2) link these object files together? For small projects with just 2-3 files there is no need to use object files. However, in a project with thousands of files, specifying all files on a single command line will cause each recompilation to take a very long fixed amount of time (e.g., many minutes). Even if we make a very small change to a single source file we will have recompile every source file! Using object files enables modular compilation. In modular compilation , we only need to recompile those source files what have changed. We can simply reuse the previously compiled object files for those source files that have not changed. Modulary compilation can drastically reduce recompile times so that it is proportional to just how many changes you have made to the source files (e.g. less than a second). One challenge with modular compilation is it drastically increases the build complexity. There are many more commands to enter on the command line, and we need to carefully rack which commands need to be redone whenever we change a C source file. In the next section, we will explore using a build framework to automate the process of modular compilation for complex C programs. To-Do On Your Own Create a new source file named avg3.c that contains the three-input average program you developed earlier. Create a header file named avg3.h which contains just the function prototype for the three-input average program. Modify avg-mfile.c to call both the two-input and the three-input avg functions. Try compiling avg3.c into its own object file named avg3.o . Link all three files (i.e., avg.o , avg3.o , avg-mfile.o ). You will see a linker error indicating that you have two functions with the same name. The compiler does not know how to disambiguate these two functions. Name the three-input average function avg3 and update the source file ( avg3.c ), header file ( avg.h ), and avg-mfile.c appropriately. Recompile the object files and try linking the program together again. Verify that it produces the expected output. 6. Experimenting with Compiling and Running C Programs for PA1 \u00b6 Let's experiment with compiling an ad-hoc test for the first programming assignment using what we have learned in this discussion section. You can use the following steps to clone your PA1 repo. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/netid % cd netid % tree Where netid is your NetID. Recall that ad-hoc testing involves compiling a program manually from command line, and using that program to print out the result of your function. Then you can verify that the results are as expected. We have included an ad-hoc test for each implementation in your repo that you can use for early experimentation. 1 2 3 4 5 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/src % gcc -Wall -Wextra -pedantic -o pow-iter-adhoc pow-iter.c pow-iter-adhoc.c % ./pow-iter-adhoc % gcc -Wall -Wextra -pedantic -o sqrt-iter-adhoc sqrt-iter.c sqrt-iter-adhoc.c % ./sqrt-iter-adhoc These ad-hoc tests will not print out the correct value because you haven't completed the programming assignment yet, but this at least illustrates how we can used what we have learned in this discussion section to compile an ad-hoc test from the command line.","title":"Section 2: Compiling and Running C Programs"},{"location":"SFU-CMPT-431-sec2-c-basics/#section-2-compiling-and-running-c-programs","text":"This section serves as gentle introduction to the basics of compiling and running C programs on the ecelinux machines.","title":"Section 2: Compiling and Running C Programs"},{"location":"SFU-CMPT-431-sec2-c-basics/#1-the-ecelinux-machines","text":"Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt Now clone the GitHub repo we will be using in this section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec2 sec2 % cd sec2 % cat README.md","title":"1. The ecelinux Machines"},{"location":"SFU-CMPT-431-sec2-c-basics/#2-using-online-tools-to-explore-c-programs","text":"In this section, we will explore to online tools that can be useful when exploring C programs. The first is Repl.it which enables us to write, compile, and run C programs in the cloud, and the second is Compiler Explore which enables us to compile C programs and view the corresponding machine instructions in the cloud.","title":"2. Using Online Tools to Explore C Programs"},{"location":"SFU-CMPT-431-sec2-c-basics/#21-replit","text":"Repl.it is a free online service which supports writing, compiling, and executing C/C++ programs completely online in your browser. It will enable us to quickly explore small C/C++ code snippets. Start a browser and go to https://Repl.it . You can use Repl.it without an account. You can always create an account later. Click new repl in the upper right-hand corner. In the Search for a language drop-down choose C and the click Create repl . You will see a default program. Replace this default program with the following program inspired by today's lecture. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } Click run . This will compile and execute your C program in the cloud and then display the output on the right. To-Do On Your Own Change the value of b to 15. Recompile and execute your C program. Is the result what you expect? Modify the avg function to find the average of three values instead of just two. Modify the main function to properly call your updated function and verify it calculates the average correctly. We will be using Repl.it throughout the course. We strongly encourage students to experiment with Repl.it frequently. The best way to truly understand computer systems programming with C and C++ is to actually write programs, and the easiest way to write C and C++ programs is to just use Repl.it!","title":"2.1. Repl.it"},{"location":"SFU-CMPT-431-sec2-c-basics/#22-compiler-explorer","text":"Compiler Explore is a free online service that compiles C programs to machine instructions and then displays these machine instructions for you to inspect completely online in your browser. It will enable us to quickly explore the connection between C and C++ code and the low-level machine instructions actually executed by the computer system. Start a browser and go to https://godbolt.org . You will see a default code snippet. Replace this code with the following code inspired by today's lecture. 1 2 3 4 5 int avg( int x, int y ) { int sum = x + y; return sum / 2; } Compiler Explore will automatically display the corresponding machine instructions on the right. It color codes C code on the left to match which exact machine instructions are produced by that C code on the right. You can right click on an instruction and select View opcode doc to learn more about what each instruction does. You can also choose from many different compilers targeting many different instruction set architectures (ISAs). Here are three different compiler/ISAs you might want to experiment with: x86-64 clang 8.0.0 : This is similar to the compiler on ecelinux MIPS gcc 5.4 (el) : This is similar to what is used in ECE 2400 RISCV-V rv32gc clang : This is similar to what is used in ECE 2400 Go ahead and choose x86-64. Notice that even though the C source code uses the integer division operator there is no division instruction on the right. This is because the compiler is smart enough to figure out that dividing by 2 is the same as shifting to the right by one bit. In the upper-right corner you will either see Compiler options or -O3 . This is where you can enter command line options that are passed to the compiler. The command line option -O3 tells the compiler to apply as many optimizations as it can. Experiment with either entering -O3 or deleting -O3 to observe the difference in the resulting machine instructions. Notice that without -O3 the compiler will generate many more instructions, and also notice that it now is using a division instruction ( idiv ). The unoptimized code would execute far slower than the optimized code. To-Do On Your Own Copy-and-paste the three-input average program you developed earlier into Compiler Explore. Inspect the corresponding machine instructions for all three compiler/ISA options mentioned above with and without optimizations.","title":"2.2. Compiler Explorer"},{"location":"SFU-CMPT-431-sec2-c-basics/#3-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocessor is not really part of the C programming language. The C preprocessor simply manipulates the plain text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. The best way to understand the C preprocessor is actually to use it to preprocess plain text files as opposed to C source files. Assume we wish to create a plain text file which includes both warm and cool colors. We could simply copy-and-paste our lists from warm-colors.txt and cool-colors.txt , but this would be redundant and difficult to maintain if we wanted to add a new warm or cool color. We can instead use the C preprocessor to include the contents of one text file in another text file. Use Micro (or Geany) to create a new file named colors-in.txt like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % micro colors-in.txt Put the following content into this file: 1 2 #include \"warm-colors.txt\" #include \"cool-colors.txt\" Recall that you can save a file from Micro using Ctrl-S and you can quit using Ctrl-Q. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. The #include directive specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). Now we can use the C preprocessor ( cpp ) to preprocess the -in.txt files into a final text file that contains both the warm and cool colors. 1 % cd ${HOME}/SFU-CMPT-431/sec2 % cpp -o colors.txt colors-in.txt % cat colors.txt The -o command line option is used to specify the name of the output file. The content of the colors.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1 \"colors-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 31 \"<command-line>\" # 1 \"/usr/include/stdc-predef.h\" 1 3 4 # 32 \"<command-line>\" 2 # 1 \"colors-in.txt\" # 1 \"warm-colors.txt\" 1 red orange yellow # 2 \"colors-in.txt\" 2 # 1 \"cool-colors.txt\" 1 blue green purple # 2 \"colors-in.txt\" 2 The C preprocessor has included all of the colors in a single output file, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. We can tell cpp to not include this extra metadata with the -P command line option. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor earlier in this section when we included the stdio.h header file which includes the declaration of the printf function. Let's now modify colors-in.txt to include each file three times: 1 2 3 4 5 6 #include \"warm-colors.txt\" #include \"warm-colors.txt\" #include \"warm-colors.txt\" #include \"cool-colors.txt\" #include \"cool-colors.txt\" #include \"cool-colors.txt\" Rerun the C preprocessor and verify that the warm and cool colors are included three times. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt While this is fine for plain text files, we need to be very careful about including the same C code multiple times when we are developing our C programs. If the compiler sees the same function defined multiple times it will cause a syntax error. More modern programming languages have built-in features to ensure code is only included a single time regardless, but in C we are forced to use the C preprocessor to ensure code is only included once. We will use a technique called include guards . An include guard will ensure that the contents of a given file is only inserted into the output file once, even if we include it multiple times. For example, modify warm-colors.txt using Micro (or Geany) as follows: 1 2 3 4 5 6 #ifndef SEC2_WARM_COLORS_TXT #define SEC2_WARM_COLORS_TXT red orange yellow #endif The #ifndef directive is a conditional which will only include the content after the directive if the given preprocessor macro is defined. The #define directive \"defines\" the given preprocessor macro. So these directives essentially check to see if WARM_COLORS_TXT is defined and if not it will include the text in the file ... and also define WARM_COLORS_TXT . If we try and include this same file again then WARM_COLORS_TXT will already be defined and we will skip over the contents of the file. Modify cool-colors.txt as follows: 1 2 3 4 5 6 #ifndef SEC2_COOL_COLORS_TXT #define SEC2_COOL_COLORS_TXT blue green purple #endif Rerun the C preprocessor and you will see that the colors are only included once because of the include guards. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % cpp -P -o colors.txt colors-in.txt % cat colors.txt The actual macro name you use for the include guard doesn't matter as long as it is unique across all files. We usually use a variation of the filename to ensure unique include guard macros. To-Do On Your Own Change the name of the macro used in both warm-colors.txt and cool-colors.txt to be COLORS_TXT . This means both files will be using the same macro name for their include guards. Rerun the C preprocessor. Try switching the order you include the files in colors.txt (e.g., include the cool colors first, and then include the warm colors). Can you explain what is going on?","title":"3. C Preprocessor"},{"location":"SFU-CMPT-431-sec2-c-basics/#4-compiling-and-running-a-single-file-c-program","text":"Now that we have explored how to use the C preprocessor for file inclusion and include guards, we will can turn out attention to writing C programs. We will begin by writing a single-file C program to calculate the average of two integers. Our goal is to reproduce what we did with Repl.it and Compiler Explorer, but by using various command line tools on the ecelinux machines. Edit the avg-sfile.c code to include an appropriate implementation of the avg function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdio.h> int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } We use a compiler to compiler the C source code into an executable binary (i.e., the actual bits) that the machine can understand. In this course we will be using the GNU C compiler ( gcc ). Let's go ahead and give this a try: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-sfile avg-sfile.c % ls The gcc command takes as input the C source file to compile and the command line option -o is used to specify the output exectutable binary (i.e., the file with the machine instructions). We also use the -Wall command line option to report all warnings. Note that gcc automatically takes care of running the C preprocessor for us. After running the gcc command you should see a new avg-sfile file in the directory. We can execute this binary by simply calling it as any other Linux command. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % ./avg-sfile Recall that a single dot ( . ) always refers to the current working directory. Essentially we are telling Linux that we want to run the executable binary named avg-sfile which is located in the current working directory. Repl.it is basically doing these same steps just in the cloud. It can be tedious to to have to carefully enter the correct commands on the command line every time we want to compile a C source file into an executable binary. In the next section, we will explore using a build framework to automate the process of building our C programs. The process of executing the avg-sfile executable and verifying its output is called ad-hoc testing . It is ad-hoc because there is no systematic and automatic way to run and verify tests. In the next section, we will explore using a test framework to automate the process of testing our C programs. Now let's examine the machine instructions using the objdump command. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % objdump -dC avg-sfile | less The objdump command takes an executable binary and shows you the machine instructions in a human readable format. We are piping it through less so we can scroll through the output. Try and find how many machine instructions are used to implement the avg function. Compiler Explore is basically doing these same steps just in the cloud. Recall what you learned from experimenting with Compiler Explore earlier in this section. Does it seem like the compiler generated optimized code or unoptimized code? You can exit less by pressing the q key. Let's recompile our program with optimizations. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -O3 -o avg-sfile avg-sfile.c % objdump -dC avg-sfile | less Now how many machine instructions are used to implement the avg function? To-Do On Your Own Copy-and-paste the three-input average program you developed earlier into avg-sfile.c . Recompile this program using gcc , and then execute this program from the command line. Verify that it produces the expected output. Inspect the corresponding machine instructions with and without optimizations using objdump .","title":"4. Compiling and Running a Single-File C Program"},{"location":"SFU-CMPT-431-sec2-c-basics/#5-compiling-and-running-a-multi-file-c-program","text":"Real C programs are almost never contained in a single file. They require many files which must be individually compiled and then linked together. Linking is the process of merging together different binary files each with its own set of machine instructions. To illustrate this process we will break our avg-sfile.c source file into two files: avg.c will contain the avg function, and avg-mfile.c will contain the main function. We will compile each of these files into its own object file and then link these object files into a complete executable binary. Here is a figure illustrating the compiler and linker flow. Go ahead and use Micro (or Geany) to create the avg.c file: 1 2 3 4 5 6 7 #include \"avg.h\" int avg ( int x , int y ) { int sum = x + y ; return sum / 2 ; } And now create the avg-mfile.c file: 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> #include \"avg.h\" int main () { int a = 10 ; int b = 20 ; int c = avg ( a , b ); printf ( \"average of %d and %d is %d \\n \" , a , b , c ); return 0 ; } We will use gcc compile the avg.c source file into the avg.o object file, and we will also use gcc to compile the avg-mfile.c source file into the avg-mfile.o object file. Finally, we can use gcc to link both object files along with the pre-compiled C standard library and any startup code to produce an executable binary. We will also need a header file named avg.h . Header files are the key to multi-file C programs. The avg-mfile.c source file needs to call the avg function, but the avg function is in a different source file. When we compile the avg-mfile.c source file, how will the compiler know that the avg function exists to ensure the programmer is not accidentally calling an undefined function? How will the compiler know what parameters the avg function takes, so it can perform type checking? The avg-mfile.c source file cannot directly include avg.c since that would result in the same function being compiled twice into two different object files (which would cause a linker error). What we need to do is have a way to tell avg-mfile.c the avg function prototype (i.e., the interface of the function including its name, parameter list, and return type) but not the avg function implementation . We do this with a function declaration . A function definition specifies both the function prototype (interface) and the implementation at the same time, while a function declaration just specifies the function prototype without the implementation. A header file contains all of the function declarations but no function definitions. All of the function definitions are placed in a source file that goes along with the header file. If we want to call a function that is defined in a different source file, then we simply use the #include directive to include the appropriate header file. The linker will take care of making sure the machine instructions corresponding to every function definition is linked together into the executable binary. Create a header file for avg.c named avg.h with the following contents. 1 2 3 4 5 6 #ifndef SEC2_AVG_H #define SEC2_AVG_H int avg ( int x , int y ); #endif Notice the include guards implemented using the C preprocessor. Let's go ahead and compile avg.c and avg-mfile.c into their corresponding object files: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -c -o avg.o avg.c % gcc -Wall -c -o avg-mfile.o avg-mfile.c We use the -c command line option to indicate that gcc should create an object file as opposed to a complete executable binary. An object file is just a piece of machine instructions. We cannot actually execute an object file; we need to link multiple object files together to create a complete executable binary. We usually use the .o filename extension to indicate that these files are object files. Let's use objdump to look inside each of these object files. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % objdump -dC avg.o % objdump -dC avg-mfile.o You should be able to see that each object file only contains a few machine instructions. The avg.o object file only contains machine instructions that correspond to the avg function, while the avg-mfile.o object file only contains machine instructions that correspond to the main function. Let's link these two object files together to create a complete executable binary that we can actually run. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-mfile avg.o avg-mfile.o % objdump -dC avg-mfile Notice that the complete executable binary contains all of the machine instructions for both the avg and main functions along with a bunch of additional system-level code (e.g., for the printf function). Let's go ahead and run the executable binary. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec2 % ./avg-mfile We can simplify this process and do the compilation and linking in a single step by specifying multiple C source files on a single command line. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec2 % gcc -Wall -o avg-mfile avg.c avg-mfile.c % ./avg-mfile This of course begs the question. If we can compile a project with multiple files simply by specifying all of the files on the command line, then why did we learn about how to: (1) compile each file individually into an object file; and (2) link these object files together? For small projects with just 2-3 files there is no need to use object files. However, in a project with thousands of files, specifying all files on a single command line will cause each recompilation to take a very long fixed amount of time (e.g., many minutes). Even if we make a very small change to a single source file we will have recompile every source file! Using object files enables modular compilation. In modular compilation , we only need to recompile those source files what have changed. We can simply reuse the previously compiled object files for those source files that have not changed. Modulary compilation can drastically reduce recompile times so that it is proportional to just how many changes you have made to the source files (e.g. less than a second). One challenge with modular compilation is it drastically increases the build complexity. There are many more commands to enter on the command line, and we need to carefully rack which commands need to be redone whenever we change a C source file. In the next section, we will explore using a build framework to automate the process of modular compilation for complex C programs. To-Do On Your Own Create a new source file named avg3.c that contains the three-input average program you developed earlier. Create a header file named avg3.h which contains just the function prototype for the three-input average program. Modify avg-mfile.c to call both the two-input and the three-input avg functions. Try compiling avg3.c into its own object file named avg3.o . Link all three files (i.e., avg.o , avg3.o , avg-mfile.o ). You will see a linker error indicating that you have two functions with the same name. The compiler does not know how to disambiguate these two functions. Name the three-input average function avg3 and update the source file ( avg3.c ), header file ( avg.h ), and avg-mfile.c appropriately. Recompile the object files and try linking the program together again. Verify that it produces the expected output.","title":"5. Compiling and Running a Multi-File C Program"},{"location":"SFU-CMPT-431-sec2-c-basics/#6-experimenting-with-compiling-and-running-c-programs-for-pa1","text":"Let's experiment with compiling an ad-hoc test for the first programming assignment using what we have learned in this discussion section. You can use the following steps to clone your PA1 repo. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/netid % cd netid % tree Where netid is your NetID. Recall that ad-hoc testing involves compiling a program manually from command line, and using that program to print out the result of your function. Then you can verify that the results are as expected. We have included an ad-hoc test for each implementation in your repo that you can use for early experimentation. 1 2 3 4 5 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/src % gcc -Wall -Wextra -pedantic -o pow-iter-adhoc pow-iter.c pow-iter-adhoc.c % ./pow-iter-adhoc % gcc -Wall -Wextra -pedantic -o sqrt-iter-adhoc sqrt-iter.c sqrt-iter-adhoc.c % ./sqrt-iter-adhoc These ad-hoc tests will not print out the correct value because you haven't completed the programming assignment yet, but this at least illustrates how we can used what we have learned in this discussion section to compile an ad-hoc test from the command line.","title":"6. Experimenting with Compiling and Running C Programs for PA1"},{"location":"SFU-CMPT-431-sec3-c-build-test/","text":"Section 3: C Build and Test Frameworks \u00b6 In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file and multi-file program that calculated the average of two integers. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. We also need to carefully track which steps need to be redone whenever we change a C source file. In this discussion section, we will explore using a build framework based on CMake to automate this process. In the previous discussion section, you also learned how to do ad-hoc testing by executing a function and then simply printing out the result to the terminal. In this discussion section, we will explore using a test framework to automate this process. Using a build and test framework is critical to productive system-level programming in C and C++. 1. The ecelinux Machines \u00b6 Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt Now clone the GitHub repo we will be using in this section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec3 sec3 % cd sec3 % tree The given src directory includes the following files: avg-sfile.c : source and main for single-file avg program avg.h : header file for the avg function avg.c : source file for the avg function avg-mfile.c : main for multi-file avg program avg-mfile-basic-test.c : most basic smoke test utst.h : simple C preprocessor macros for unit testing 2. Using Makefiles to Compile C Programs \u00b6 Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % gcc -Wall -o avg-sfile avg-sfile.c % ./avg-sfile Let's now remove the binary so we are back to a clean directory: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % rm -rf avg-sfile We will start by using a new tool called make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: 1 2 target : prerequisite0 prerequisite1 prerequisite2 < TAB > command A rule specifies how to generate the target file using the list of prerequisite files and the given Linux command. make is smart enough to know it should rerun the command if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist then it needs to look for some other rule to generate that prerequisite first. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters <TAB> , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use your favorite text editor to create a file named Makefile in the src directory with the following content: 1 2 3 4 5 avg-sfile : avg - sfile . c <TAB>gcc -Wall -o avg-sfile avg-sfile.c clean : <TAB>rm -rf avg-sfile We can use the newly created Makefile like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". In this case, we want to make the avg-sfile executable. make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-sfile executable. It will then check to make sure the prerequisites exist and that they are up-to-date, and then it will run the command specified in the rule for avg-sfile . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-sfile executable. Try running make again: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make detects that the prerequisite (i.e., avg-sfile.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-sfile.c source file. Modify the printf statement as follows: 1 printf ( \"avg( %d, %d ) == %d \\n \" , a , b , c ); You can recompile and re-execute the program like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make will automatically detect that the prerequisite has changed and recompile the executable appropriately. This ability to automatically track dependencies and recompile just what is necessary is a key benefit of using a tool like make . Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % ls % make clean % ls To-Do On Your Own Add two rules to your Makefile to compile avg.o and avg-mfile.o . Add a rule that links these two object files together and produces avg-mfile . Update the rule for the clean target appropriately. Carefully consider what command and prerequisites to use for each target. Test out your Makefile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly? 3. Using CMake to Generate Makefiles for Compiling C Programs \u00b6 While using make can help automate the build process, the corresponding Makefiles can quickly grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . It can also be complicated to add support for code coverage, memory checking, and debug vs.~evaluation builds. New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a sophisticated Makefile for us to use. A CMakeLists.txt is a plain text file with a list of commands that specify what tasks we would like the generated Makefile to perform. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean % trash Makefile Let's create a simple CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program. User your favorite text editor to create a file named CMakeLists.txt in the src directory with the following content: 1 2 3 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) add_executable ( avg-sfile avg-sfile.c ) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project. Line 3 specifies that we want to generate a Makefile that can compile an executable named avg-sfile form the avg-sfile.c source file. Now let's run the cmake command to generate a Makefile we can use to compile avg-sfile : 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % cmake . % ls % less Makefile The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-sfile . 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile CMake will automatically create some useful targets like clean . 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean Writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with many files. To-Do On Your Own Add another line to your CMakeLists.txt file to specify that we want to generate a Makefile that can be used to compile avg-mfile from avg-mfile.c and avg.c . Use CMake to generate the corresponding Makefile and then use make to compile avg-mfile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly? 4. Using CTest for Systematic Unit Testing \u00b6 So far we have been using \"ad-hoc testing\". For example, the main function in avg-sfile.c will execute the avg function with one set of inputs and then print the result to the terminal. If it is not what we expected, we can debug our program until it meets our expectations. Unfortunately, ad-hoc testing is error prone and not easily reproducible. If you later make a change to your implementation, you would have to take another look at the output to ensure your implementation still works. If another developer wants to understand your implementation and verify that it is working, he or she would also need to take a look at the output and think hard about what is the expected result. Ad-hoc testing is usually verbose, which makes it error prone, and does not use any kind of standard test output. While ad-hoc testing might be feasible for very simple implementations, it is obviously not a scalable approach when developing the more complicated implementations we will tackle in this course. New tools have been developed to help automate the process of testing implementations. These tools provide a systematic way to do automated unit testing including standardized naming conventions, test output, and test drivers. In this course, we will be using CTest as a key step in our test framework. CTest elegantly integrates with CMake to create a unified built and test framework. Each unit test will be a stand-alone test program where the test code is contained within the main function. The following is an example of a unit test program for our avg function: 1 2 3 4 5 6 7 8 9 #include <stdio.h> #include \"avg.h\" #include \"utst.h\" int main () { UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 15 ); return 0 ; } We provide a simple library of test macros in utst.h which can be used to write various testing assertions. The UTST_ASSERT_INT_EQ macro asserts that the two given integer parameters are equal. If they are indeed equal, then the macro prints out the values, and we move on to the next test assertion. If they are not equal, the the macro prints out an error message and exits the program with the value 1. Recall that when the program returns 0 it means success, and when the program returns 1 it means failure. The return value enables our test program to inform CTest of whether or not our test passed of failed. We have provided the above test program in the repository for this discussion section. To use CTest, we need to tell it about this new test program. We can do this by simply adding a new line to our CMakeLists.txt file. Here is an example CMakeLists.txt file: 1 2 3 4 5 6 7 8 9 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) enable_testing () add_executable ( avg-sfile avg-sfile.c ) add_executable ( avg-mfile avg-mfile.c avg.c ) add_executable ( avg-mfile-basic-test avg-mfile-basic-test.c avg.c ) add_test ( avg-mfile-basic-test avg-mfile-basic-test ) Line 3 tells CMake to turn on support for testing with CTest. Line 6 specifies how to build avg-mfile . Line 8 specifies how to build the avg-mfile-basic-test test program. Line 9 tells CMake that avg-mfile-basic-test is a test that should be managed by CTest. Modify your CMakeLists.txt file to look like what is given above, rerun cmake, build the test, and run it. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % cmake . % make avg-mfile-basic-test % ./avg-mfile-basic-test You should see some output which indicates the passing test assertion. CMake provides a test target which can run all of the tests and provides a summary. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make test It is always a good idea to occasionally force a test to fail to ensure your test framework is behaving correctly. Change the test assertion in avg-mfile-basic-test.c to look like this: 1 UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 16 ); Then rebuild and rerun the test like this: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-mfile-basic-test % make test % ./avg-mfile-basic-test You should see the test failing in the test summary, and then see additional information about the failing test assertion when you explicitly run the test program. avg-mfile-basic-test is a kind of \"smoke\" test which is used to test the absolute most basic functionality of an implementation. We will also be doing extensive directed testing and random testing . In directed testing, you explicitly use test assertions to test as many corner cases as possible. In random testing, you use random input values and compare the output to some golden \"reference\" implementation to hopefully catch bugs missed in your directed testing. To-Do On Your Own Create another unit test program named avg-mfile-directed-test.c for directed testing. Use the macros in utst.h to begin/end your test program and for test assertions. Try to test several different corner cases. Modify your CMakeLists.txt file to include this new unit test program. Use CMake to regenerate the corresponding Makefile , use make to build your test program, and then run it. Ensure that make test runs both the basic and directed tests. 5. Using a Build Directory \u00b6 Take a look at the source directory. It likely contains a mess of generated directories, object files, executables, etc. It is usually very bad practice to build C programs directly in the source directory. It is much better to build C programs in a completely separate build directory. Adding support for these build directories in a Makefile is complex, but CMake makes it easy. Let's start by deleting all generated content in your source directory: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean % trash CMakeCache.txt CMakeFiles *.cmake Now let's first create a separate build directory, use CMake to create a new Makefile , and finally build and run all of our tests. 1 2 3 4 5 6 % cd ${ HOME } /SFU-CMPT-431/sec3 % mkdir build % cd build % cmake ../src % make % make test A separate build directory makes it easy to do a \"clean build\" where you start your build from scratch. Simply remove the build directory and start again like this: 1 2 3 4 5 6 7 % cd ${ HOME } /SFU-CMPT-431/sec3 % trash build % mkdir build % cd build % cmake ../src % make % make test You should never check in your build directory or any generated content into Git. Only source files are checked into Git! To-Do On Your Own Add a new test assertion to your directed tests. Rebuild and rerun the test program in the separate build directory. 6. Experimenting with Build and Test Frameworks for PA1 \u00b6 Let's experiment with the build and test frameworks for the first programming assignment using what we have learned in this discussion section. You can use the following steps to clone your PA1 repo. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/netid % cd netid % tree For each programming assignment, we will provide you a skeleton for your project including a complete CMakeLists.txt . In the common case, you should not need to modify the CMakeLists.txt unless you want to incorporate additional source and/or test files. The programming assignments are setup to use a separate build directory. The programming assignments also group all of the tests into their own separate directory. You can use the following steps to use the build framework with the first programming assignment. 1 2 3 4 5 6 % mkdir -p ${ HOME } /SFU-CMPT-431/netid/pa1-math % mkdir build % cd build % cmake .. % make check % make check-milestone check will run all of the tests for the entire PA, while check-milestone will only run the tests for the milestone. If there is a test failure, we can \"zoom in\" to build a single test program and run it in isolation like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-basic-test % ./pow-iter-basic-test You can build and run the test program on a single line like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-basic-test && ./pow-iter-basic-test The && bash operator enables running multiple commands on the same command line. Let's take a closer look at how we will structure our test programs. Here is the content of pow-iter-directed-test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <stdlib.h> #include \"utst.h\" #include \"pow-iter.h\" void test_case_1_small_large () { printf ( \" \\n %s \\n \" , __func__ ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 1 , 100 ), 1.0000 , 0.0001 ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 1.1 , 300 ) / 2617010996188.4634 , 1.0 , 0.0001 ); } void test_case_2_zero_small () { printf ( \" \\n %s \\n \" , __func__ ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 0 , 1 ), 0.0000 , 0.0001 ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 0 , 2 ), 0.0000 , 0.0001 ); } int main ( int argc , char * argv [] ) { int n = ( argc == 1 ) ? 0 : atoi ( argv [ 1 ] ); if ( ( n == 0 ) || ( n == 1 ) ) test_case_1_small_large (); if ( ( n == 0 ) || ( n == 2 ) ) test_case_2_zero_small (); printf ( \" \\n \" ); return 0 ; } Our test programs will consist of a number of test cases . Each test case is a separate function which should focus on testing a specific subset of inputs. In this example, test case 1 tests small numbers raised to a large exponent, while test case 2 tests a base of zero raised to a small exponent. Each test case should start with a statement similar to lines 8 and 14. __func__ is a built-in variable which contains the function name, so these lines basically print out the name of the function. Each test case should then use a series of UTST_ASSERT macros to check that the implementation produces the expected results. For example, on line 9 we check that 1 raised to 100 is equal to 1.0. On line 10 we check 1.1 raised to 300. Here we need to be careful because floating point arithmetic can sometimes not be as precise as we expect. So in this example we calculate the result of our implementation, divide this result by the correct answer, and then make sure this ratio, is close to 1. The main function's job is to simply call each test case function. Note that we get a single command line argument which specifies which test case we want to run. If we do not specify a command line argument then we run all of the test cases. Let's run all of the direct test cases. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test Then we can \"zoom in\" further, and run a single test case within a single test program so we see exactly which test assertion is failing. The following will build the directed test program, explicitly run just test case 1, and then explicitly run just test case 2. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test 1 % ./pow-iter-directed-test 2 Once we fix the bug, then we can \"zoom out\" and move on to the next failing test case, or to the next failing test program. Now let's try adding a new test case that checks that a small number raised to zero is 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... void test_case_3_small_zero() { printf(\"\\n%s\\n\", __func__ ); UTST_ASSERT_FLOAT_EQ( pow_iter( 10, 0 ), 1.0000, 0.0001 ); } int main( int argc, char* argv[] ) { int n = ( argc == 1 ) ? 0 : atoi( argv[1] ); if ( ( n == 0 ) || ( n == 1 ) ) test_case_1_small_large(); if ( ( n == 0 ) || ( n == 2 ) ) test_case_2_zero_small(); if ( ( n == 0 ) || ( n == 3 ) ) test_case_3_small_zero(); printf( \"\\n\" ); return 0; } We have added a new test case function with an appropriate test case number and name, and we have also added a new line to the main function to call this new test case function. Let's go ahead and run all of the test cases and then run just this new test case. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test % ./pow-iter-directed-test 3","title":"Section 3: C Build and Test Frameworks"},{"location":"SFU-CMPT-431-sec3-c-build-test/#section-3-c-build-and-test-frameworks","text":"In the previous discussion section, you learned how to explicitly compile and run C programs from the command line. You learned how to use the GNU C Compiler ( gcc ) to compile both a single-file and multi-file program that calculated the average of two integers. You probably noticed that it can be tedious to have to carefully enter the correct commands on the command line. We also need to carefully track which steps need to be redone whenever we change a C source file. In this discussion section, we will explore using a build framework based on CMake to automate this process. In the previous discussion section, you also learned how to do ad-hoc testing by executing a function and then simply printing out the result to the terminal. In this discussion section, we will explore using a test framework to automate this process. Using a build and test framework is critical to productive system-level programming in C and C++.","title":"Section 3: C Build and Test Frameworks"},{"location":"SFU-CMPT-431-sec3-c-build-test/#1-the-ecelinux-machines","text":"Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt Now clone the GitHub repo we will be using in this section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec3 sec3 % cd sec3 % tree The given src directory includes the following files: avg-sfile.c : source and main for single-file avg program avg.h : header file for the avg function avg.c : source file for the avg function avg-mfile.c : main for multi-file avg program avg-mfile-basic-test.c : most basic smoke test utst.h : simple C preprocessor macros for unit testing","title":"1. The ecelinux Machines"},{"location":"SFU-CMPT-431-sec3-c-build-test/#2-using-makefiles-to-compile-c-programs","text":"Let's remind ourselves how to explicitly compile and run a single-file C program on the command line: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % gcc -Wall -o avg-sfile avg-sfile.c % ./avg-sfile Let's now remove the binary so we are back to a clean directory: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % rm -rf avg-sfile We will start by using a new tool called make which was specifically designed to help automate the process of building C programs. The key to using make is developing a Makefile . A Makefile is a plain text file which contains a list of rules which together specify how to execute commands to accomplish some task. Each rule has the following syntax: 1 2 target : prerequisite0 prerequisite1 prerequisite2 < TAB > command A rule specifies how to generate the target file using the list of prerequisite files and the given Linux command. make is smart enough to know it should rerun the command if any of the prerequisites change, and it also knows that if one of the prerequisites does not exist then it needs to look for some other rule to generate that prerequisite first. It is very important to note that make requires commands in a rule to start with a real TAB character. So you should not type the letters <TAB> , but you should instead press the TAB key and verify that it has inserted a real TAB character (i.e., if you move the left/right arrows the cursor should jump back and forth across the TAB). This is the only time in the course where you should use a real TAB character as opposed to spaces. Let's create a simple Makefile to compile a single-file C program. Use your favorite text editor to create a file named Makefile in the src directory with the following content: 1 2 3 4 5 avg-sfile : avg - sfile . c <TAB>gcc -Wall -o avg-sfile avg-sfile.c clean : <TAB>rm -rf avg-sfile We can use the newly created Makefile like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make will by default use the Makefile in the current directory. make takes a command line argument specifying what you want \"make\". In this case, we want to make the avg-sfile executable. make will look at all of the rules in the Makefile to find a rule that specifies how to make the avg-sfile executable. It will then check to make sure the prerequisites exist and that they are up-to-date, and then it will run the command specified in the rule for avg-sfile . In this case, that command is gcc . make will output to the terminal every command it runs, so you should see it output the command line which uses gcc to generate the avg-sfile executable. Try running make again: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make detects that the prerequisite (i.e., avg-sfile.c ) has not changed and so it does not recompile the executable. Now let's try making a change in the avg-sfile.c source file. Modify the printf statement as follows: 1 printf ( \"avg( %d, %d ) == %d \\n \" , a , b , c ); You can recompile and re-execute the program like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile make will automatically detect that the prerequisite has changed and recompile the executable appropriately. This ability to automatically track dependencies and recompile just what is necessary is a key benefit of using a tool like make . Makefiles can also include targets which are not actually files. Our example Makefile includes a clean target which will delete any generated executables. Let's clean up our directory like this: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % ls % make clean % ls To-Do On Your Own Add two rules to your Makefile to compile avg.o and avg-mfile.o . Add a rule that links these two object files together and produces avg-mfile . Update the rule for the clean target appropriately. Carefully consider what command and prerequisites to use for each target. Test out your Makefile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly?","title":"2. Using Makefiles to Compile C Programs"},{"location":"SFU-CMPT-431-sec3-c-build-test/#3-using-cmake-to-generate-makefiles-for-compiling-c-programs","text":"While using make can help automate the build process, the corresponding Makefiles can quickly grow to be incredibly complicated. Creating and maintaining these Makefiles can involve significant effort. It can be particularly challenging to ensure all of the dependencies between the various source and header files are always correctly captured in the Makefile . It can also be complicated to add support for code coverage, memory checking, and debug vs.~evaluation builds. New tools have been developed to help automate the process of managing Makefiles (which in turn automate the build process). Automation is the key to effective software development methodologies. In this course, we will be using CMake as a key step in our build framework. CMake takes as input a simple CMakeLists.txt file and generates a sophisticated Makefile for us to use. A CMakeLists.txt is a plain text file with a list of commands that specify what tasks we would like the generated Makefile to perform. Before getting started let's remove any files we have generated and also remove the Makefile we developed in the previous section. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean % trash Makefile Let's create a simple CMakeLists.txt that can be used to generate a Makefile which will in turn be used to compile a single-file C program. User your favorite text editor to create a file named CMakeLists.txt in the src directory with the following content: 1 2 3 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) add_executable ( avg-sfile avg-sfile.c ) Line 1 specifies the CMake version we are assuming, and line 2 specifies that we will be using CMake with a C project. Line 3 specifies that we want to generate a Makefile that can compile an executable named avg-sfile form the avg-sfile.c source file. Now let's run the cmake command to generate a Makefile we can use to compile avg-sfile : 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % cmake . % ls % less Makefile The cmake command will by default use the CMakeLists.txt in the directory given as a command line argument. CMake takes care of figuring out what C compilers are available and then generating the Makefile appropriately. You can see that CMake has automatically generated a pretty sophisticated Makefile . Let's go ahead and use this Makefile to build avg-sfile . 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-sfile % ./avg-sfile CMake will automatically create some useful targets like clean . 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean Writing a CMakeLists.txt is simpler than writing a Makefile , especially when we start working with many files. To-Do On Your Own Add another line to your CMakeLists.txt file to specify that we want to generate a Makefile that can be used to compile avg-mfile from avg-mfile.c and avg.c . Use CMake to generate the corresponding Makefile and then use make to compile avg-mfile . Try changing avg.c and rerunning make . Does your program recompile correctly? Try changing avg.h and rerunning make . Does your program recompile correctly?","title":"3. Using CMake to Generate Makefiles for Compiling C Programs"},{"location":"SFU-CMPT-431-sec3-c-build-test/#4-using-ctest-for-systematic-unit-testing","text":"So far we have been using \"ad-hoc testing\". For example, the main function in avg-sfile.c will execute the avg function with one set of inputs and then print the result to the terminal. If it is not what we expected, we can debug our program until it meets our expectations. Unfortunately, ad-hoc testing is error prone and not easily reproducible. If you later make a change to your implementation, you would have to take another look at the output to ensure your implementation still works. If another developer wants to understand your implementation and verify that it is working, he or she would also need to take a look at the output and think hard about what is the expected result. Ad-hoc testing is usually verbose, which makes it error prone, and does not use any kind of standard test output. While ad-hoc testing might be feasible for very simple implementations, it is obviously not a scalable approach when developing the more complicated implementations we will tackle in this course. New tools have been developed to help automate the process of testing implementations. These tools provide a systematic way to do automated unit testing including standardized naming conventions, test output, and test drivers. In this course, we will be using CTest as a key step in our test framework. CTest elegantly integrates with CMake to create a unified built and test framework. Each unit test will be a stand-alone test program where the test code is contained within the main function. The following is an example of a unit test program for our avg function: 1 2 3 4 5 6 7 8 9 #include <stdio.h> #include \"avg.h\" #include \"utst.h\" int main () { UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 15 ); return 0 ; } We provide a simple library of test macros in utst.h which can be used to write various testing assertions. The UTST_ASSERT_INT_EQ macro asserts that the two given integer parameters are equal. If they are indeed equal, then the macro prints out the values, and we move on to the next test assertion. If they are not equal, the the macro prints out an error message and exits the program with the value 1. Recall that when the program returns 0 it means success, and when the program returns 1 it means failure. The return value enables our test program to inform CTest of whether or not our test passed of failed. We have provided the above test program in the repository for this discussion section. To use CTest, we need to tell it about this new test program. We can do this by simply adding a new line to our CMakeLists.txt file. Here is an example CMakeLists.txt file: 1 2 3 4 5 6 7 8 9 cmake_minimum_required ( VERSION 2.8 ) enable_language ( C ) enable_testing () add_executable ( avg-sfile avg-sfile.c ) add_executable ( avg-mfile avg-mfile.c avg.c ) add_executable ( avg-mfile-basic-test avg-mfile-basic-test.c avg.c ) add_test ( avg-mfile-basic-test avg-mfile-basic-test ) Line 3 tells CMake to turn on support for testing with CTest. Line 6 specifies how to build avg-mfile . Line 8 specifies how to build the avg-mfile-basic-test test program. Line 9 tells CMake that avg-mfile-basic-test is a test that should be managed by CTest. Modify your CMakeLists.txt file to look like what is given above, rerun cmake, build the test, and run it. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % cmake . % make avg-mfile-basic-test % ./avg-mfile-basic-test You should see some output which indicates the passing test assertion. CMake provides a test target which can run all of the tests and provides a summary. 1 2 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make test It is always a good idea to occasionally force a test to fail to ensure your test framework is behaving correctly. Change the test assertion in avg-mfile-basic-test.c to look like this: 1 UTST_ASSERT_INT_EQ ( avg ( 10 , 20 ), 16 ); Then rebuild and rerun the test like this: 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make avg-mfile-basic-test % make test % ./avg-mfile-basic-test You should see the test failing in the test summary, and then see additional information about the failing test assertion when you explicitly run the test program. avg-mfile-basic-test is a kind of \"smoke\" test which is used to test the absolute most basic functionality of an implementation. We will also be doing extensive directed testing and random testing . In directed testing, you explicitly use test assertions to test as many corner cases as possible. In random testing, you use random input values and compare the output to some golden \"reference\" implementation to hopefully catch bugs missed in your directed testing. To-Do On Your Own Create another unit test program named avg-mfile-directed-test.c for directed testing. Use the macros in utst.h to begin/end your test program and for test assertions. Try to test several different corner cases. Modify your CMakeLists.txt file to include this new unit test program. Use CMake to regenerate the corresponding Makefile , use make to build your test program, and then run it. Ensure that make test runs both the basic and directed tests.","title":"4. Using CTest for Systematic Unit Testing"},{"location":"SFU-CMPT-431-sec3-c-build-test/#5-using-a-build-directory","text":"Take a look at the source directory. It likely contains a mess of generated directories, object files, executables, etc. It is usually very bad practice to build C programs directly in the source directory. It is much better to build C programs in a completely separate build directory. Adding support for these build directories in a Makefile is complex, but CMake makes it easy. Let's start by deleting all generated content in your source directory: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec3/src % make clean % trash CMakeCache.txt CMakeFiles *.cmake Now let's first create a separate build directory, use CMake to create a new Makefile , and finally build and run all of our tests. 1 2 3 4 5 6 % cd ${ HOME } /SFU-CMPT-431/sec3 % mkdir build % cd build % cmake ../src % make % make test A separate build directory makes it easy to do a \"clean build\" where you start your build from scratch. Simply remove the build directory and start again like this: 1 2 3 4 5 6 7 % cd ${ HOME } /SFU-CMPT-431/sec3 % trash build % mkdir build % cd build % cmake ../src % make % make test You should never check in your build directory or any generated content into Git. Only source files are checked into Git! To-Do On Your Own Add a new test assertion to your directed tests. Rebuild and rerun the test program in the separate build directory.","title":"5. Using a Build Directory"},{"location":"SFU-CMPT-431-sec3-c-build-test/#6-experimenting-with-build-and-test-frameworks-for-pa1","text":"Let's experiment with the build and test frameworks for the first programming assignment using what we have learned in this discussion section. You can use the following steps to clone your PA1 repo. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/netid % cd netid % tree For each programming assignment, we will provide you a skeleton for your project including a complete CMakeLists.txt . In the common case, you should not need to modify the CMakeLists.txt unless you want to incorporate additional source and/or test files. The programming assignments are setup to use a separate build directory. The programming assignments also group all of the tests into their own separate directory. You can use the following steps to use the build framework with the first programming assignment. 1 2 3 4 5 6 % mkdir -p ${ HOME } /SFU-CMPT-431/netid/pa1-math % mkdir build % cd build % cmake .. % make check % make check-milestone check will run all of the tests for the entire PA, while check-milestone will only run the tests for the milestone. If there is a test failure, we can \"zoom in\" to build a single test program and run it in isolation like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-basic-test % ./pow-iter-basic-test You can build and run the test program on a single line like this: 1 2 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-basic-test && ./pow-iter-basic-test The && bash operator enables running multiple commands on the same command line. Let's take a closer look at how we will structure our test programs. Here is the content of pow-iter-directed-test . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdio.h> #include <stdlib.h> #include \"utst.h\" #include \"pow-iter.h\" void test_case_1_small_large () { printf ( \" \\n %s \\n \" , __func__ ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 1 , 100 ), 1.0000 , 0.0001 ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 1.1 , 300 ) / 2617010996188.4634 , 1.0 , 0.0001 ); } void test_case_2_zero_small () { printf ( \" \\n %s \\n \" , __func__ ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 0 , 1 ), 0.0000 , 0.0001 ); UTST_ASSERT_FLOAT_EQ ( pow_iter ( 0 , 2 ), 0.0000 , 0.0001 ); } int main ( int argc , char * argv [] ) { int n = ( argc == 1 ) ? 0 : atoi ( argv [ 1 ] ); if ( ( n == 0 ) || ( n == 1 ) ) test_case_1_small_large (); if ( ( n == 0 ) || ( n == 2 ) ) test_case_2_zero_small (); printf ( \" \\n \" ); return 0 ; } Our test programs will consist of a number of test cases . Each test case is a separate function which should focus on testing a specific subset of inputs. In this example, test case 1 tests small numbers raised to a large exponent, while test case 2 tests a base of zero raised to a small exponent. Each test case should start with a statement similar to lines 8 and 14. __func__ is a built-in variable which contains the function name, so these lines basically print out the name of the function. Each test case should then use a series of UTST_ASSERT macros to check that the implementation produces the expected results. For example, on line 9 we check that 1 raised to 100 is equal to 1.0. On line 10 we check 1.1 raised to 300. Here we need to be careful because floating point arithmetic can sometimes not be as precise as we expect. So in this example we calculate the result of our implementation, divide this result by the correct answer, and then make sure this ratio, is close to 1. The main function's job is to simply call each test case function. Note that we get a single command line argument which specifies which test case we want to run. If we do not specify a command line argument then we run all of the test cases. Let's run all of the direct test cases. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test Then we can \"zoom in\" further, and run a single test case within a single test program so we see exactly which test assertion is failing. The following will build the directed test program, explicitly run just test case 1, and then explicitly run just test case 2. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test 1 % ./pow-iter-directed-test 2 Once we fix the bug, then we can \"zoom out\" and move on to the next failing test case, or to the next failing test program. Now let's try adding a new test case that checks that a small number raised to zero is 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ... void test_case_3_small_zero() { printf(\"\\n%s\\n\", __func__ ); UTST_ASSERT_FLOAT_EQ( pow_iter( 10, 0 ), 1.0000, 0.0001 ); } int main( int argc, char* argv[] ) { int n = ( argc == 1 ) ? 0 : atoi( argv[1] ); if ( ( n == 0 ) || ( n == 1 ) ) test_case_1_small_large(); if ( ( n == 0 ) || ( n == 2 ) ) test_case_2_zero_small(); if ( ( n == 0 ) || ( n == 3 ) ) test_case_3_small_zero(); printf( \"\\n\" ); return 0; } We have added a new test case function with an appropriate test case number and name, and we have also added a new line to the main function to call this new test case function. Let's go ahead and run all of the test cases and then run just this new test case. 1 2 3 4 % cd ${ HOME } /SFU-CMPT-431/netid/pa1-math/build % make pow-iter-directed-test % ./pow-iter-directed-test % ./pow-iter-directed-test 3","title":"6. Experimenting with Build and Test Frameworks for PA1"},{"location":"SFU-CMPT-431-sec4-c-test-debug/","text":"Section 4: C Testing and Debugging \u00b6 In the previous discussion section, you learned how to use C build and test frameworks to help automate the process of compiling and verifying your programs In this discussion, we will continue to learn about new tools that can help us better test and debug our programs. 1. The ecelinux Machines \u00b6 Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt For this discussion section you will need to make a copy of the repo we will be using so you can push to it. Go to the section's repo here: https://github.com/cornell-SFU-CMPT-431/ece2400-sec4 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/SFU-CMPT-431-sec4 Where githubid is your GitHubID. Now clone the github repo for this discussion section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:githubid/SFU-CMPT-431-sec4 sec4 % cd sec4 % tree Where again, the githubid is your GitHubID. The given src directory includes the following files: avg-test.c : source and test for avg function sort-test.c : source and test for sort function utst.h : simple C preprocessor macros for unit testing .travis.yml : TravisCI configuration script 2. Using GDB for Debugging \u00b6 There are two kinds of C/C++ programmers in the world: printf debuggers and GDB debuggers. Prof. Batten used to be a printf debuggers but teaching this course has converted him to be a GDB advocate. He will share his perspectives on this in the discussion section. Let's start by compiling a single-file program that uses the UTST macros to test our ubiquitous avg function. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % gcc -Wall -g -o avg-test avg-test.c % ./avg-test Notice how we include the -g option to turn on support for debugging. This code has a bug and should fail the test. Let's start by using printf debugging. Add some extra printfs to observe the state of the program as it executes. 1 2 3 4 5 6 7 int avg ( int x , int y ) { printf ( \"x = %d, y = %d \\n \" , x , y ); int sum = x + x ; printf ( \"sum = %d \\n \" , sum ); return sum / 2 ; } You should be able to see that the value for the sum variable is incorrect, but the value for the x and y variables are correct. This means we can narrow our focus to line 4 in the above code snippet. Hopefully, you should be able to spot the bug. Fix the bug, recompile, and rerun the program. Let's now try tracing the execution of this program using GDB. Then you can start GDB like this 1 2 % cd ${ HOME } /SFU-CMPT-431/sec4 % gdb -tui avg-test GDB will drop you into a GDB \"prompt\" which you can use to interactively execute your program. Your source code will show up at the top, and the GDB prompt is at the bottom. Here are some useful GDB commands: break location : set a breakpoint run : start running the program record : start recording the execution for reverse debugging step : execute the next C statement, step into a function call next : execute the next C statement, do not step into a function call rs : reserve step, undo the execution of current C statement print var : print a C variable continue : continue on to the next breakpoint quit : exit GDB refresh : refresh the source code display GDB is very sophisticated so of course there are many more commands you can use, but these are enough to get started. Let's start by just running the program in GDB: 1 (gdb) run Now let's try again, but first let's set a breakpoint to tell GDB to stop at a certain function or line in the program. The following will set a breakpoint at the beginning of the main function. 1 (gdb) break main You can see a little b+ marker in the margin next to the first statement in the main function indicating the location of the breakpoint. We can now use run to start the program running. The execution should stop at the beginning of the function main . You should see the first line of the function highlighted. 1 (gdb) run We can use record to turn on recording to enable reverse debugging and then we can step through the execution of each C statement using the step command. 1 2 (gdb) record (gdb) step Keep using step until you get into the avg function You can print out the value of any variable using the print command: 1 2 3 (gdb) print x (gdb) print y (gdb) print sum You can also step backwards using the rs command: 1 (gdb) rs Try stepping forward and backward through the avg function and print out various variables to see how they change during the execution. You can use quit to exit. 1 (gdb) quit Now fix the bug and rerun the test. To-Do On Your Own Try compiling sort-test.c and executing the resulting binary. The test should fail. Use GDB debugging to find the bug and fix it. Think critically about whether or not the sort function should swap the given inputs, and then use GDB to trace and see if it is or is not swapping as expected. 3. Using GCOV for Code Coverage \u00b6 One you have developed your implementation and the corresponding basic, directed, and random tests, you can then move on to understanding the quality of your current set of tests. One way to do this is to use code coverage tools. The idea here is to use a tool which will count how many times each line of code in your program is executed when running all of your tests. If there are lines of code which have never executed, then this is a good indicator that you need more tests to verify that part of your code. Let's start by recompiling our avg-test.c and turning on code coverage support. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % gcc -Wall -g --coverage -o avg-test avg-test.c % ./avg-test This will generate additional data in avg-test.gcda . To make this data easy to read and understand we need to run two more tools: lcov and genhtml like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % lcov --capture --directory . --output-file coverage.info % genhtml coverage.info --output-directory coverage-html These tools will produce easy to read HTML reports. While you can use a browser like firefox , it is faster (especially when working on the server) to use a terminal based browser like elinks : 1 % elinks coverage-html/index.html You should be able to use your mouse to browse to the report for the avg-test.c source file and verify that you are achieving 100% code coverage. Note that 100% code coverage is not the same as 100% path coverage; ask the instructors for more on this. Also note that 100% code coverage does not mean your program is guaranteed to be correct! To-Do On Your Own Try compiling sort-test.c and executing the resulting binary with support for code coverage (after you fix the bug from the previous section!). Use the code coverage reports to verify that the test has less than 100% code coverage. Add more tests to improve the code coverage to 100%. 4. Using TravisCI and Codecov.io for Continuous Integration \u00b6 Continuous integration is the process of continually integrating, testing, and evaluating your code. We will be using two tools to facilitate continuous integration. The first is TravisCI, an online service which is tightly coupled to GitHub. TravisCI will automatically run all tests for a project every time code is pushed to GitHub. The second is Codecov.io, an online service for visualizing code coverage. To start, you need to enable TravisCI for the remote repository on GitHub. Log into TravisCI using your GitHub ID and password: https://travis-ci.org/profile Once you have signed in, you should go to your TravisCI profile and find the list of your public GitHub repositories. You may need to click Sync to ensure that TravisCI has the most recent view of your public repositories on GitHub. You might need to refresh the page a few times. Turn on TravisCI with the little \"switch\" next to the repository we have been using in this tutorial ( githubid/SFU-CMPT-431-sec4 ). After enabling TravisCI for the githubid/SFU-CMPT-431-sec4 repository, you should be able to go to the TravisCI page for this repository: https://travis-ci.org/githubid/SFU-CMPT-431-sec4 TravisCI will report that there are no builds for this repository yet. TravisCI looks for a special file named .travis.yml in the top of your repository to determine how to build and test your project. We have already created one of those files for you, and you can see it here: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec4 % cat .travis.yml Go ahead and commit all of the work you have done in this tutorial, then push your local commits to the remote repository on GitHub. Revisit the TravisCI page for this repository, you should see TravisCI starting to build and run all of your tests. https://travis-ci.org/githubid/SFU-CMPT-431-sec4 Just like we can use TravisCI to automatically run tests, we can use Codecov.io to automatically prepare code coverage reports on every commit. You can see your code coverage reports here: https://codecov.io/gh/githubid/SFU-CMPT-431-sec4 5. Try Steps for Programming Assignments \u00b6 Spend some time looking at the .travis.yml file for PA1. Look at the TravisCI results for the PA1 milestone and also look at the Codecov.io results. You can find these results by clicking on the appropriate badges in your PA1 README.","title":"Section 4: C Testing and Debugging"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#section-4-c-testing-and-debugging","text":"In the previous discussion section, you learned how to use C build and test frameworks to help automate the process of compiling and verifying your programs In this discussion, we will continue to learn about new tools that can help us better test and debug our programs.","title":"Section 4: C Testing and Debugging"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#1-the-ecelinux-machines","text":"Follow the same process as in the last section. login to a workstation with your NetID and password use MobaXterm to log into the ecelinux servers make sure you source the setup script verify ECE2400 is in your prompt For this discussion section you will need to make a copy of the repo we will be using so you can push to it. Go to the section's repo here: https://github.com/cornell-SFU-CMPT-431/ece2400-sec4 Click on the \"Fork\" button. Wait a few seconds and then visit the new copy of this repo in your own person GitHub workspace: https://github.com/githubid/SFU-CMPT-431-sec4 Where githubid is your GitHubID. Now clone the github repo for this discussion section using the following commands: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:githubid/SFU-CMPT-431-sec4 sec4 % cd sec4 % tree Where again, the githubid is your GitHubID. The given src directory includes the following files: avg-test.c : source and test for avg function sort-test.c : source and test for sort function utst.h : simple C preprocessor macros for unit testing .travis.yml : TravisCI configuration script","title":"1. The ecelinux Machines"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#2-using-gdb-for-debugging","text":"There are two kinds of C/C++ programmers in the world: printf debuggers and GDB debuggers. Prof. Batten used to be a printf debuggers but teaching this course has converted him to be a GDB advocate. He will share his perspectives on this in the discussion section. Let's start by compiling a single-file program that uses the UTST macros to test our ubiquitous avg function. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % gcc -Wall -g -o avg-test avg-test.c % ./avg-test Notice how we include the -g option to turn on support for debugging. This code has a bug and should fail the test. Let's start by using printf debugging. Add some extra printfs to observe the state of the program as it executes. 1 2 3 4 5 6 7 int avg ( int x , int y ) { printf ( \"x = %d, y = %d \\n \" , x , y ); int sum = x + x ; printf ( \"sum = %d \\n \" , sum ); return sum / 2 ; } You should be able to see that the value for the sum variable is incorrect, but the value for the x and y variables are correct. This means we can narrow our focus to line 4 in the above code snippet. Hopefully, you should be able to spot the bug. Fix the bug, recompile, and rerun the program. Let's now try tracing the execution of this program using GDB. Then you can start GDB like this 1 2 % cd ${ HOME } /SFU-CMPT-431/sec4 % gdb -tui avg-test GDB will drop you into a GDB \"prompt\" which you can use to interactively execute your program. Your source code will show up at the top, and the GDB prompt is at the bottom. Here are some useful GDB commands: break location : set a breakpoint run : start running the program record : start recording the execution for reverse debugging step : execute the next C statement, step into a function call next : execute the next C statement, do not step into a function call rs : reserve step, undo the execution of current C statement print var : print a C variable continue : continue on to the next breakpoint quit : exit GDB refresh : refresh the source code display GDB is very sophisticated so of course there are many more commands you can use, but these are enough to get started. Let's start by just running the program in GDB: 1 (gdb) run Now let's try again, but first let's set a breakpoint to tell GDB to stop at a certain function or line in the program. The following will set a breakpoint at the beginning of the main function. 1 (gdb) break main You can see a little b+ marker in the margin next to the first statement in the main function indicating the location of the breakpoint. We can now use run to start the program running. The execution should stop at the beginning of the function main . You should see the first line of the function highlighted. 1 (gdb) run We can use record to turn on recording to enable reverse debugging and then we can step through the execution of each C statement using the step command. 1 2 (gdb) record (gdb) step Keep using step until you get into the avg function You can print out the value of any variable using the print command: 1 2 3 (gdb) print x (gdb) print y (gdb) print sum You can also step backwards using the rs command: 1 (gdb) rs Try stepping forward and backward through the avg function and print out various variables to see how they change during the execution. You can use quit to exit. 1 (gdb) quit Now fix the bug and rerun the test. To-Do On Your Own Try compiling sort-test.c and executing the resulting binary. The test should fail. Use GDB debugging to find the bug and fix it. Think critically about whether or not the sort function should swap the given inputs, and then use GDB to trace and see if it is or is not swapping as expected.","title":"2. Using GDB for Debugging"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#3-using-gcov-for-code-coverage","text":"One you have developed your implementation and the corresponding basic, directed, and random tests, you can then move on to understanding the quality of your current set of tests. One way to do this is to use code coverage tools. The idea here is to use a tool which will count how many times each line of code in your program is executed when running all of your tests. If there are lines of code which have never executed, then this is a good indicator that you need more tests to verify that part of your code. Let's start by recompiling our avg-test.c and turning on code coverage support. 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % gcc -Wall -g --coverage -o avg-test avg-test.c % ./avg-test This will generate additional data in avg-test.gcda . To make this data easy to read and understand we need to run two more tools: lcov and genhtml like this: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec4 % lcov --capture --directory . --output-file coverage.info % genhtml coverage.info --output-directory coverage-html These tools will produce easy to read HTML reports. While you can use a browser like firefox , it is faster (especially when working on the server) to use a terminal based browser like elinks : 1 % elinks coverage-html/index.html You should be able to use your mouse to browse to the report for the avg-test.c source file and verify that you are achieving 100% code coverage. Note that 100% code coverage is not the same as 100% path coverage; ask the instructors for more on this. Also note that 100% code coverage does not mean your program is guaranteed to be correct! To-Do On Your Own Try compiling sort-test.c and executing the resulting binary with support for code coverage (after you fix the bug from the previous section!). Use the code coverage reports to verify that the test has less than 100% code coverage. Add more tests to improve the code coverage to 100%.","title":"3. Using GCOV for Code Coverage"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#4-using-travisci-and-codecovio-for-continuous-integration","text":"Continuous integration is the process of continually integrating, testing, and evaluating your code. We will be using two tools to facilitate continuous integration. The first is TravisCI, an online service which is tightly coupled to GitHub. TravisCI will automatically run all tests for a project every time code is pushed to GitHub. The second is Codecov.io, an online service for visualizing code coverage. To start, you need to enable TravisCI for the remote repository on GitHub. Log into TravisCI using your GitHub ID and password: https://travis-ci.org/profile Once you have signed in, you should go to your TravisCI profile and find the list of your public GitHub repositories. You may need to click Sync to ensure that TravisCI has the most recent view of your public repositories on GitHub. You might need to refresh the page a few times. Turn on TravisCI with the little \"switch\" next to the repository we have been using in this tutorial ( githubid/SFU-CMPT-431-sec4 ). After enabling TravisCI for the githubid/SFU-CMPT-431-sec4 repository, you should be able to go to the TravisCI page for this repository: https://travis-ci.org/githubid/SFU-CMPT-431-sec4 TravisCI will report that there are no builds for this repository yet. TravisCI looks for a special file named .travis.yml in the top of your repository to determine how to build and test your project. We have already created one of those files for you, and you can see it here: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec4 % cat .travis.yml Go ahead and commit all of the work you have done in this tutorial, then push your local commits to the remote repository on GitHub. Revisit the TravisCI page for this repository, you should see TravisCI starting to build and run all of your tests. https://travis-ci.org/githubid/SFU-CMPT-431-sec4 Just like we can use TravisCI to automatically run tests, we can use Codecov.io to automatically prepare code coverage reports on every commit. You can see your code coverage reports here: https://codecov.io/gh/githubid/SFU-CMPT-431-sec4","title":"4. Using TravisCI and Codecov.io for Continuous Integration"},{"location":"SFU-CMPT-431-sec4-c-test-debug/#5-try-steps-for-programming-assignments","text":"Spend some time looking at the .travis.yml file for PA1. Look at the TravisCI results for the PA1 milestone and also look at the Codecov.io results. You can find these results by clicking on the appropriate badges in your PA1 README.","title":"5. Try Steps for Programming Assignments"},{"location":"SFU-CMPT-431-sec5-c-profiling/","text":"Section 5: C Profiling \u00b6 In this discussion, we will explore how to measure the performance of a C evaluation program. Follow the same process as in the previous discussion section. You need to login to a workstation with your NetID and password. Start a terminal and then don't forget to source the setup script! 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec5-c-profiling sec5 % cd sec5 % ls 1. Warmup: Implement Array Average Functions \u00b6 Take a look at the array-eval.c source file. You will see four functions: init_array : initialize an array of integers with random values avg_array : find average of an array of integers init_parray : initialize an array of pointers to integers avg_parray : find average of an array of pointers to integers The first two functions operate on an array of integers, while the second two functions operate on an array of pointers to integers. Start by sketching a state diagram for the given main program assuming size is set to 3. Work through the state diagram and stop when you get to the call to the avg_array function. Use this state diagram to understand the difference between the array of integers vs. the array of pointers to integers. Now implement the avg_array function which should find the average of the integers stored in the given array. Then implement the avg_parray function which should find the average of the integers pointed to by the given array. Compile and execute your program a couple of times, changing the seed passed into srand each time. Verify that the value returned by avg_array always equals the value returned by avg_parray and that the average is always around 500. 2. Measuring Execution Time \u00b6 Now assume we want to quantitatively measure how long it takes to initialize both arrays and then calculate the averages. To do this, we can use the time functions provided by the C standard library in the sys/time.h header file. Go ahead and add the following header to your evaluation program: 1 #include <sys/time.h> We can use the gettimeofday function to get the current time: http://man7.org/linux/man-pages/man2/gettimeofday.2.html This function takes as a parameter a pointer to a struct of type struct timeval . It uses call-by-pointer semantics to update this struct with the current time with a precision of 10s of microseconds. The struct has two fields: tv_sec is the number of seconds and tv_usec is the number of microseconds since January 1, 1970. We can use gettimeofday like this to quantitatively measure how long it takes to run an experiment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Track time using timers struct timeval start ; struct timeval end ; // Start tracking time gettimeofday ( & start , NULL ); // Run the experiment // ... // Stop tracking time gettimeofday ( & end , NULL ); // Calculate elapsed time double elapsed = ( end . tv_sec - start . tv_sec ) + ( ( end . tv_usec - start . tv_usec ) / 1000000.0 ); printf ( \"Elapsed time for trial is %f \\n \" , elapsed ); Modify the evaluation program to measure how long one experiment takes. You will notice that the execution time is very short ... so short that it is too fast for the resolution of the timer. We need to run a subtrial in a loop many times to make sure we have a long enough experiment that we can get a reasonable accurate time measurement. Put the subtrial in a loop like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x ; int y ; for ( int j = 0 ; j < 100000 ; j ++ ) { int array [ size ]; init_array ( array , size ); int * parray [ size ]; init_parray ( parray , array , size ); x = avg_array ( array , size ); y = avg_parray ( parray , size ); } Your program should now run for a couple of seconds and this should enable a much more precise time measurement. Try running the program at least five times and write down the results for each trial. Is the execution time always the same? If not, why not? We need to do several trials and then take the average execution time to ensure we can get a good estimate of the execution time. Restructure your evaluation program to look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int main( void) { int ntrials = 5; int nsubtrials = 1e5; double elapsed_avg = 0.0; for ( int i = 0; i < ntrials; i++ ) { // Track time using timers struct timeval start; struct timeval end; // Start tracking time gettimeofday( &start, NULL ); // Run the experiment for ( int j = 0; j < nsubtrials; j++ ) { // ... run one trial ... } // Stop tracking time gettimeofday( &end, NULL ); // Calculate elapsed time double elapsed = ( end.tv_sec - start.tv_sec ) + ( ( end.tv_usec - start.tv_usec ) / 1000000.0 ); elapsed_avg += elapsed; printf( \"Elapsed time for trial %d is %f\\n\", i, elapsed ); } // Calculate average elapsed time per trial elapsed_avg = elapsed_avg / ntrials; printf( \"Elapsed time (averaged) is %f\\n\", elapsed_avg ); } Now use your evaluation program to quantitatively measure the execution time of this experiment. 3. Profiling Execution Time \u00b6 The previous section enables us to measure the overall execution time, but we might also be interested to know which functions are taking the most time. This can help us focus on the important hotspots for optimization. We can use profiling to do this kind of performance analysis. We will look at two profiling tools: gprof and perf . Let's start by recompiling our program with support for profiling: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec5 % gcc -Wall -pg -o array-eval array-eval.c Notice the -pg command line option. This tells GCC to enable support for profiling. Now we run the program and use the gprof tool to analyze the execution time: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec5 % ./array-eval % gprof ./array-eval The output will have two parts: a flat profile and a call graph profile. The flat profile specifies how many times each function was called and how much time was spent in each function. The call graph profile additionally indicates what exact sequence of function calls led let to a specific function call, and how much time was spent in that specific function call. Why do you think more time is spent in init_array ? Let's now use a different tool called perf : 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec5 % perf record ./array-eval % perf report --stdio The output will show a flat profile, but it also includes how much time was spent in various functions contained in the standard C library. Does this information help explain why more time is spent in init_array ? We can use these profiling tools to help identify hotspots in our code for optimization. Hotspots might be due to a small function which is called many, many times, or a function which is only called a few times but takes a very long time to execute.","title":"SFU CMPT 431 sec5 c profiling"},{"location":"SFU-CMPT-431-sec5-c-profiling/#section-5-c-profiling","text":"In this discussion, we will explore how to measure the performance of a C evaluation program. Follow the same process as in the previous discussion section. You need to login to a workstation with your NetID and password. Start a terminal and then don't forget to source the setup script! 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec5-c-profiling sec5 % cd sec5 % ls","title":"Section 5: C Profiling"},{"location":"SFU-CMPT-431-sec5-c-profiling/#1-warmup-implement-array-average-functions","text":"Take a look at the array-eval.c source file. You will see four functions: init_array : initialize an array of integers with random values avg_array : find average of an array of integers init_parray : initialize an array of pointers to integers avg_parray : find average of an array of pointers to integers The first two functions operate on an array of integers, while the second two functions operate on an array of pointers to integers. Start by sketching a state diagram for the given main program assuming size is set to 3. Work through the state diagram and stop when you get to the call to the avg_array function. Use this state diagram to understand the difference between the array of integers vs. the array of pointers to integers. Now implement the avg_array function which should find the average of the integers stored in the given array. Then implement the avg_parray function which should find the average of the integers pointed to by the given array. Compile and execute your program a couple of times, changing the seed passed into srand each time. Verify that the value returned by avg_array always equals the value returned by avg_parray and that the average is always around 500.","title":"1. Warmup: Implement Array Average Functions"},{"location":"SFU-CMPT-431-sec5-c-profiling/#2-measuring-execution-time","text":"Now assume we want to quantitatively measure how long it takes to initialize both arrays and then calculate the averages. To do this, we can use the time functions provided by the C standard library in the sys/time.h header file. Go ahead and add the following header to your evaluation program: 1 #include <sys/time.h> We can use the gettimeofday function to get the current time: http://man7.org/linux/man-pages/man2/gettimeofday.2.html This function takes as a parameter a pointer to a struct of type struct timeval . It uses call-by-pointer semantics to update this struct with the current time with a precision of 10s of microseconds. The struct has two fields: tv_sec is the number of seconds and tv_usec is the number of microseconds since January 1, 1970. We can use gettimeofday like this to quantitatively measure how long it takes to run an experiment. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Track time using timers struct timeval start ; struct timeval end ; // Start tracking time gettimeofday ( & start , NULL ); // Run the experiment // ... // Stop tracking time gettimeofday ( & end , NULL ); // Calculate elapsed time double elapsed = ( end . tv_sec - start . tv_sec ) + ( ( end . tv_usec - start . tv_usec ) / 1000000.0 ); printf ( \"Elapsed time for trial is %f \\n \" , elapsed ); Modify the evaluation program to measure how long one experiment takes. You will notice that the execution time is very short ... so short that it is too fast for the resolution of the timer. We need to run a subtrial in a loop many times to make sure we have a long enough experiment that we can get a reasonable accurate time measurement. Put the subtrial in a loop like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int x ; int y ; for ( int j = 0 ; j < 100000 ; j ++ ) { int array [ size ]; init_array ( array , size ); int * parray [ size ]; init_parray ( parray , array , size ); x = avg_array ( array , size ); y = avg_parray ( parray , size ); } Your program should now run for a couple of seconds and this should enable a much more precise time measurement. Try running the program at least five times and write down the results for each trial. Is the execution time always the same? If not, why not? We need to do several trials and then take the average execution time to ensure we can get a good estimate of the execution time. Restructure your evaluation program to look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int main( void) { int ntrials = 5; int nsubtrials = 1e5; double elapsed_avg = 0.0; for ( int i = 0; i < ntrials; i++ ) { // Track time using timers struct timeval start; struct timeval end; // Start tracking time gettimeofday( &start, NULL ); // Run the experiment for ( int j = 0; j < nsubtrials; j++ ) { // ... run one trial ... } // Stop tracking time gettimeofday( &end, NULL ); // Calculate elapsed time double elapsed = ( end.tv_sec - start.tv_sec ) + ( ( end.tv_usec - start.tv_usec ) / 1000000.0 ); elapsed_avg += elapsed; printf( \"Elapsed time for trial %d is %f\\n\", i, elapsed ); } // Calculate average elapsed time per trial elapsed_avg = elapsed_avg / ntrials; printf( \"Elapsed time (averaged) is %f\\n\", elapsed_avg ); } Now use your evaluation program to quantitatively measure the execution time of this experiment.","title":"2. Measuring Execution Time"},{"location":"SFU-CMPT-431-sec5-c-profiling/#3-profiling-execution-time","text":"The previous section enables us to measure the overall execution time, but we might also be interested to know which functions are taking the most time. This can help us focus on the important hotspots for optimization. We can use profiling to do this kind of performance analysis. We will look at two profiling tools: gprof and perf . Let's start by recompiling our program with support for profiling: 1 2 % cd ${ HOME } /SFU-CMPT-431/sec5 % gcc -Wall -pg -o array-eval array-eval.c Notice the -pg command line option. This tells GCC to enable support for profiling. Now we run the program and use the gprof tool to analyze the execution time: 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec5 % ./array-eval % gprof ./array-eval The output will have two parts: a flat profile and a call graph profile. The flat profile specifies how many times each function was called and how much time was spent in each function. The call graph profile additionally indicates what exact sequence of function calls led let to a specific function call, and how much time was spent in that specific function call. Why do you think more time is spent in init_array ? Let's now use a different tool called perf : 1 2 3 % cd ${ HOME } /SFU-CMPT-431/sec5 % perf record ./array-eval % perf report --stdio The output will show a flat profile, but it also includes how much time was spent in various functions contained in the standard C library. Does this information help explain why more time is spent in init_array ? We can use these profiling tools to help identify hotspots in our code for optimization. Hotspots might be due to a small function which is called many, many times, or a function which is only called a few times but takes a very long time to execute.","title":"3. Profiling Execution Time"},{"location":"SFU-CMPT-431-sec7-cxx-intro/","text":"Section 7: Introduction to C++ \u00b6 In this discussion, we will transition from C to C++ by incrementally moving a simple C structure into C++. We will work on the following concepts in this section: C++ Structure and Class Static member functions in C++ structure Non-static member functions in C++ structure/class Before you start, let's source our setup script like this: 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${HOME}/SFU-CMPT-431 % cd ${HOME}/SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec7-cxx-intro.git sec7 % cd sec7 % ls The repo includes the following files: c-version/ directory c-version/complex.c : a C implementation of complex_t structure cxx-versions/ directory cxx-versions/complex-v1.cc : version 1 of our C++ implementation of Complex structure. This version introduces C++ structure and static member functions cxx-versions/complex-v2.cc : version 2 of our C++ implementation of Complex structure. This version introduces non-static member functions for a structure in C++ and how to call them. cxx-versions/complex-v3.cc : version 3 of our C++ implementation of Complex structure. This version introduces how to define and use constructors for a structure in C++. Students will also practice how to pass a variable to a function by reference. cxx-versions/complex-v4.cc : version 4 of our C++ implementation of Complex structure. This version introduces copy constructor and operator overloading. 1. Step 1: C version Understand the implementation of complex_t structure in c-version/complex.c Compile and run the program like this 1 2 3 cd c-version/ gcc -Wall -o complex complex.c ./complex 2. Step 2: First C++ version of complex_t In this version, we're making the first steps toward C++. First, we change how to declare a structure. We use C++ coding convention to name our structure Complex instead of complex_t in C. Second, we move add and print functions inside the definition of Complex , and make the functions static . Third, in main , we call the two functions using a namespace Complex Your task : Implement the add function 3. Step 3: Second C++ version In this version, we make both add and print functions non-static. In main , we change how we call the two functions. Now every call to add and print is associated with a specific instance of Complex . Also you may notice that, the this_ variables in complex-v1.cc are replaced with C++ keyword this . In C++, this is a pointer to the current instance of a structure or class. Your task : Implement the add function 4. Step 4: Third C++ version In this version, we introduce a constructor for our Complex structure. The constructor helps us initialize member fields of the structure. In main , we use the constructor to initialize a structure instance instead of initializing each member field directly. Your task : Implement the add function. The function now takes a reference to a structure instance instead of a pointer. 5. Step 5: Fourth C++ version Your tasks First, you make a copy constructor that takes a constant reference to an instance of Complex and initialize all member fields by copying real and imag from the input x object. Second, you overload the operator+ so that we can add two Complex instances together.","title":"SFU CMPT 431 sec7 cxx intro"},{"location":"SFU-CMPT-431-sec7-cxx-intro/#section-7-introduction-to-c","text":"In this discussion, we will transition from C to C++ by incrementally moving a simple C structure into C++. We will work on the following concepts in this section: C++ Structure and Class Static member functions in C++ structure Non-static member functions in C++ structure/class Before you start, let's source our setup script like this: 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${HOME}/SFU-CMPT-431 % cd ${HOME}/SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec7-cxx-intro.git sec7 % cd sec7 % ls The repo includes the following files: c-version/ directory c-version/complex.c : a C implementation of complex_t structure cxx-versions/ directory cxx-versions/complex-v1.cc : version 1 of our C++ implementation of Complex structure. This version introduces C++ structure and static member functions cxx-versions/complex-v2.cc : version 2 of our C++ implementation of Complex structure. This version introduces non-static member functions for a structure in C++ and how to call them. cxx-versions/complex-v3.cc : version 3 of our C++ implementation of Complex structure. This version introduces how to define and use constructors for a structure in C++. Students will also practice how to pass a variable to a function by reference. cxx-versions/complex-v4.cc : version 4 of our C++ implementation of Complex structure. This version introduces copy constructor and operator overloading. 1. Step 1: C version Understand the implementation of complex_t structure in c-version/complex.c Compile and run the program like this 1 2 3 cd c-version/ gcc -Wall -o complex complex.c ./complex 2. Step 2: First C++ version of complex_t In this version, we're making the first steps toward C++. First, we change how to declare a structure. We use C++ coding convention to name our structure Complex instead of complex_t in C. Second, we move add and print functions inside the definition of Complex , and make the functions static . Third, in main , we call the two functions using a namespace Complex Your task : Implement the add function 3. Step 3: Second C++ version In this version, we make both add and print functions non-static. In main , we change how we call the two functions. Now every call to add and print is associated with a specific instance of Complex . Also you may notice that, the this_ variables in complex-v1.cc are replaced with C++ keyword this . In C++, this is a pointer to the current instance of a structure or class. Your task : Implement the add function 4. Step 4: Third C++ version In this version, we introduce a constructor for our Complex structure. The constructor helps us initialize member fields of the structure. In main , we use the constructor to initialize a structure instance instead of initializing each member field directly. Your task : Implement the add function. The function now takes a reference to a structure instance instead of a pointer. 5. Step 5: Fourth C++ version Your tasks First, you make a copy constructor that takes a constant reference to an instance of Complex and initialize all member fields by copying real and imag from the input x object. Second, you overload the operator+ so that we can add two Complex instances together.","title":"Section 7: Introduction to C++"},{"location":"SFU-CMPT-431-sec8-cxx-class/","text":"Section 8: C++ Class \u00b6 Before you start, let's source our setup script like this: 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${HOME}/SFU-CMPT-431 % cd ${HOME}/SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec8-cxx-class.git sec8 % cd sec8 % ls 1. Part 1: Organize your code in C++ So far in lectures, we have seen C++ code written all together in one single .cc file. That's not the case in practice when you need to deal with large and complex code base. Let's consider an example of the Complex class in our discussion section last week. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 # include < cstdio > //======================================================================== // Complex //======================================================================== // Declaration and definition of Complex class and its members class Complex { public : //---------------------------------------------------------------------- // constructors //---------------------------------------------------------------------- Complex ( double real_ , double imag_ ) { real = real_ ; imag = imag_ ; } Complex ( const Complex & x ) { real = x . real ; imag = x . imag ; } //---------------------------------------------------------------------- // add //---------------------------------------------------------------------- // Add \"x\" complex number to \"this\" complex number void add ( const Complex & x ) { real += x . real ; imag += x . imag ; } //------------------------------------------------------------------------ // print //------------------------------------------------------------------------ // Print \"this\" complex number void print () { std :: printf ( \"%.2f+%.2fi\" , real , imag ); } private : double real ; double imag ; }; //======================================================================== // operator+ overload //======================================================================== Complex operator + ( const Complex & x , const Complex & y ) { Complex tmp = x ; tmp . add ( y ); return tmp ; } //======================================================================== // main //======================================================================== int main ( void ) { // Create complex number \"a\" by calling the constructor of Complex Complex a ( 1.5 , 2.5 ); std :: printf ( \"a = \" ); a . print (); printf ( \"\\n\" ); // Create complex number \"b\" by calling the constructor of Complex Complex b ( 3.5 , 4.5 ); std :: printf ( \"b = \" ); b . print (); printf ( \"\\n\" ); // Add \"a\" and \"b\" together and store the sum to \"c\" std :: printf ( \"Doing c = a + b ...\\n\" ); Complex c = a + b ; // Print out \"c\" std :: printf ( \"c = \" ); c . print (); printf ( \"\\n\" ); // Add \"b\" to \"a\" std :: printf ( \"Doing a += b ...\\n\" ); a . add ( b ); // Print out \"a\" std :: printf ( \"a = \" ); a . print (); printf ( \"\\n\" ); return 0 ; } Here we declare and define Complex class and its members (i.e., member functions and member fields) all together in one .cc file. We also have a main function that uses the class. Let's imagine that your class has tens of member functions, each of which takes many lines of code to implement. How would your source file look like? Gigantic! Following are some drawbacks of this monolithic approach: Very large code base -> very hard to maintain and debug Declarations and definitions are put together -> very hard to see the interface of a class Hard to include a class into another file or project Instead, we should break the code into multiple files complex.h : contains only declarations of related classes, functions, and variables and no implementation detail. complex.cc : contains only definition/implementation of classes, functions, and variables declared in the header file complex.h . This file needs to include the header file. complex-main.cc : contains only user code that uses the class. This file needs to include the header file. Your tasks Go to part1/ directory We already provide you the header file complex.h Copy the implementation of Complex class's functions and the overloaded operator++ into complex.cc . We already give you an example of the class's default constructor. Copy the main function into complex-main.cc Compile your code using g++ 2. Part 2: Make your RVector class In this part, we will implement an RVector data structure in C++. RVector works exactly like the rvector_int_t that you implemented in PA 2. You will need to implement the following functions in part2/rvector.cc RVector::RVector() - default constructor: initialize m_max_size , m_size , and m_arr to default values. Remember that the RVector is empty initially. RVector::RVector( size_t max_size ) - a constructor: initialize m_max_size to max_size , m_size and m_arr to default values. Remember that the RVector is empty initially. RVector::RVector( const RVector& x ) - a copy constructor: copy all numbers from vector x to this vector. Remember to allocate memory properly for this constructor. RVector::~RVector() - a destructor: deallocate any dynamically allocated memory associated with this RVector . void RVector::push_back( int num ) : push back a new number into this vector int RVector::at( size_t index ) : return a number at a given index. Throw an OutOfRangeException when the index is out of bound After you finish implementing all functions, you will need to write a small ad-hoc tests in part2/rvector-main.cc to test them. Compile and run the test using g++ .","title":"SFU CMPT 431 sec8 cxx class"},{"location":"SFU-CMPT-431-sec8-cxx-class/#section-8-c-class","text":"Before you start, let's source our setup script like this: 1 % source setup-SFU-CMPT-431.sh Now clone the github repo for this discussion section. No need to fork the repo, just clone it. 1 2 3 4 5 % mkdir -p ${HOME}/SFU-CMPT-431 % cd ${HOME}/SFU-CMPT-431 % git clone git@github.com:cornell-SFU-CMPT-431/ece2400-sec8-cxx-class.git sec8 % cd sec8 % ls 1. Part 1: Organize your code in C++ So far in lectures, we have seen C++ code written all together in one single .cc file. That's not the case in practice when you need to deal with large and complex code base. Let's consider an example of the Complex class in our discussion section last week. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 # include < cstdio > //======================================================================== // Complex //======================================================================== // Declaration and definition of Complex class and its members class Complex { public : //---------------------------------------------------------------------- // constructors //---------------------------------------------------------------------- Complex ( double real_ , double imag_ ) { real = real_ ; imag = imag_ ; } Complex ( const Complex & x ) { real = x . real ; imag = x . imag ; } //---------------------------------------------------------------------- // add //---------------------------------------------------------------------- // Add \"x\" complex number to \"this\" complex number void add ( const Complex & x ) { real += x . real ; imag += x . imag ; } //------------------------------------------------------------------------ // print //------------------------------------------------------------------------ // Print \"this\" complex number void print () { std :: printf ( \"%.2f+%.2fi\" , real , imag ); } private : double real ; double imag ; }; //======================================================================== // operator+ overload //======================================================================== Complex operator + ( const Complex & x , const Complex & y ) { Complex tmp = x ; tmp . add ( y ); return tmp ; } //======================================================================== // main //======================================================================== int main ( void ) { // Create complex number \"a\" by calling the constructor of Complex Complex a ( 1.5 , 2.5 ); std :: printf ( \"a = \" ); a . print (); printf ( \"\\n\" ); // Create complex number \"b\" by calling the constructor of Complex Complex b ( 3.5 , 4.5 ); std :: printf ( \"b = \" ); b . print (); printf ( \"\\n\" ); // Add \"a\" and \"b\" together and store the sum to \"c\" std :: printf ( \"Doing c = a + b ...\\n\" ); Complex c = a + b ; // Print out \"c\" std :: printf ( \"c = \" ); c . print (); printf ( \"\\n\" ); // Add \"b\" to \"a\" std :: printf ( \"Doing a += b ...\\n\" ); a . add ( b ); // Print out \"a\" std :: printf ( \"a = \" ); a . print (); printf ( \"\\n\" ); return 0 ; } Here we declare and define Complex class and its members (i.e., member functions and member fields) all together in one .cc file. We also have a main function that uses the class. Let's imagine that your class has tens of member functions, each of which takes many lines of code to implement. How would your source file look like? Gigantic! Following are some drawbacks of this monolithic approach: Very large code base -> very hard to maintain and debug Declarations and definitions are put together -> very hard to see the interface of a class Hard to include a class into another file or project Instead, we should break the code into multiple files complex.h : contains only declarations of related classes, functions, and variables and no implementation detail. complex.cc : contains only definition/implementation of classes, functions, and variables declared in the header file complex.h . This file needs to include the header file. complex-main.cc : contains only user code that uses the class. This file needs to include the header file. Your tasks Go to part1/ directory We already provide you the header file complex.h Copy the implementation of Complex class's functions and the overloaded operator++ into complex.cc . We already give you an example of the class's default constructor. Copy the main function into complex-main.cc Compile your code using g++ 2. Part 2: Make your RVector class In this part, we will implement an RVector data structure in C++. RVector works exactly like the rvector_int_t that you implemented in PA 2. You will need to implement the following functions in part2/rvector.cc RVector::RVector() - default constructor: initialize m_max_size , m_size , and m_arr to default values. Remember that the RVector is empty initially. RVector::RVector( size_t max_size ) - a constructor: initialize m_max_size to max_size , m_size and m_arr to default values. Remember that the RVector is empty initially. RVector::RVector( const RVector& x ) - a copy constructor: copy all numbers from vector x to this vector. Remember to allocate memory properly for this constructor. RVector::~RVector() - a destructor: deallocate any dynamically allocated memory associated with this RVector . void RVector::push_back( int num ) : push back a new number into this vector int RVector::at( size_t index ) : return a number at a given index. Throw an OutOfRangeException when the index is out of bound After you finish implementing all functions, you will need to write a small ad-hoc tests in part2/rvector-main.cc to test them. Compile and run the test using g++ .","title":"Section 8: C++ Class"},{"location":"SFU-CMPT-431-tut1-linux-git/","text":"Tutorial 1: Linux and Git \u00b6","title":"SFU CMPT 431 tut1 linux git"},{"location":"SFU-CMPT-431-tut1-linux-git/#tutorial-1-linux-and-git","text":"","title":"Tutorial 1: Linux and Git"},{"location":"SFU-CMPT-431-tut2-c-basics/","text":"Tutorial 2 : Compiling and Running C Programs \u00b6 The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-SFU-CMPT-431.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-SFU-CMPT-431/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/SFU-CMPT-431-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone https://github.com/githubid/SFU-CMPT-431-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-SFU-CMPT-431.sh script, and your specific environment may be different from what is assumed in this tutorial. 1. Using the C Preprocessor \u00b6 Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor 1.1. The #define Directive \u00b6 The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros 1.2. The #ifdef Directive \u00b6 1.3. The #include Directive \u00b6 The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 \"cs-pioneers-women-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 1 \"cs-pioneers-women-in.txt\" # 1 \"cs-pioneers-intro.txt\" 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 \"cs-pioneers-women-in.txt\" 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{<>}) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files. 1.4. Include Guards \u00b6 2. Writing a Single-File C Program \u00b6 3. Compiling a Single-File C Program \u00b6 4. Writing a Multi-File C Program \u00b6 5. Compiling a Multi-File C Program \u00b6","title":"SFU CMPT 431 tut2 c basics"},{"location":"SFU-CMPT-431-tut2-c-basics/#tutorial-2-compiling-and-running-c-programs","text":"The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-SFU-CMPT-431.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-SFU-CMPT-431/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/SFU-CMPT-431-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone https://github.com/githubid/SFU-CMPT-431-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-SFU-CMPT-431.sh script, and your specific environment may be different from what is assumed in this tutorial.","title":"Tutorial 2 : Compiling and Running C Programs"},{"location":"SFU-CMPT-431-tut2-c-basics/#1-using-the-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor","title":"1. Using the C Preprocessor"},{"location":"SFU-CMPT-431-tut2-c-basics/#11-the-define-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros","title":"1.1. The #define Directive"},{"location":"SFU-CMPT-431-tut2-c-basics/#12-the-ifdef-directive","text":"","title":"1.2. The #ifdef Directive"},{"location":"SFU-CMPT-431-tut2-c-basics/#13-the-include-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 \"cs-pioneers-women-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 1 \"cs-pioneers-women-in.txt\" # 1 \"cs-pioneers-intro.txt\" 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 \"cs-pioneers-women-in.txt\" 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{<>}) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files.","title":"1.3. The #include Directive"},{"location":"SFU-CMPT-431-tut2-c-basics/#14-include-guards","text":"","title":"1.4. Include Guards"},{"location":"SFU-CMPT-431-tut2-c-basics/#2-writing-a-single-file-c-program","text":"","title":"2. Writing a Single-File C Program"},{"location":"SFU-CMPT-431-tut2-c-basics/#3-compiling-a-single-file-c-program","text":"","title":"3. Compiling a Single-File C Program"},{"location":"SFU-CMPT-431-tut2-c-basics/#4-writing-a-multi-file-c-program","text":"","title":"4. Writing a Multi-File C Program"},{"location":"SFU-CMPT-431-tut2-c-basics/#5-compiling-a-multi-file-c-program","text":"","title":"5. Compiling a Multi-File C Program"},{"location":"SFU-CMPT-431-tut3-c-basics/","text":"Tutorial 3 : Compiling and Running C Programs \u00b6 The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-SFU-CMPT-431.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-SFU-CMPT-431/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/SFU-CMPT-431-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone https://github.com/githubid/SFU-CMPT-431-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-SFU-CMPT-431.sh script, and your specific environment may be different from what is assumed in this tutorial. 1. Using the C Preprocessor \u00b6 Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor 1.1. The #define Directive \u00b6 The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros 1.2. The #ifdef Directive \u00b6 1.3. The #include Directive \u00b6 The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 \"cs-pioneers-women-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 1 \"cs-pioneers-women-in.txt\" # 1 \"cs-pioneers-intro.txt\" 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 \"cs-pioneers-women-in.txt\" 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{<>}) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files. 1.4. Include Guards \u00b6 2. Writing a Single-File C Program \u00b6 3. Compiling a Single-File C Program \u00b6 4. Writing a Multi-File C Program \u00b6 5. Compiling a Multi-File C Program \u00b6","title":"SFU CMPT 431 tut3 c basics"},{"location":"SFU-CMPT-431-tut3-c-basics/#tutorial-3-compiling-and-running-c-programs","text":"The first few programming assignments for this course will use the C programming language. In lecture we use Compiler Explorer and Repl.it to quickly experiment with small C programs, but eventually we need to actually write and compile C programs on a real machine. This tutorial discusses how we can use the open-source GNU C compiler ( gcc ) to compile our C programs on the \\TT{ecelinux} machines. We will experiment with both single-file C programs (simple but not representative of real C projects) and multi-file programs (more complex but also more realistic). In this tutorial, we will be running \\TT{gcc} directly from the command line so we can understand each step. In the next tutorial, we will see how we can use various tools to automate this process. All of the tools are installed and available on the ecelinux machines. This tutorial assumes that students have completed the tutorial on Linux and Git. We strongly recommend students also read Chapters 1-6 in the course text book, ``All of Programming,'' by A. Hilton and A. Bracy (2015). Chapters 5-6 are particularly relevant since they discuss the general process of compiling, testing, and debugging C programs. To follow along with the tutorial, access the course computing resources, and type the commands without the % character (for the bash prompt). In addition to working through the commands in the tutorial, you should also try the more open-ended tasks marked To-Do On Your Own . Before you begin, make sure that you have sourced the setup-SFU-CMPT-431.sh script or that you have added it to your .bashrc script, which will then source the script every time you login. Sourcing the setup script sets up the environment required for this class. You should start by forking the tutorial repository on GitHub. Go to the GitHub page for the tutorial repository located here: https://github.com/cornell-SFU-CMPT-431/ece2400-tut2-c-basics . Click on Fork in the upper right-hand corner. If asked where to fork this repository, choose your personal GitHub account. After a few seconds, you should have a new repository in your account: https://github.com/githubid/SFU-CMPT-431-tut2-c-basics Where githubid is your GitHub username on github.com . Now access an ecelinux machine and clone your copy of the tutorial repository as follows: 1 2 3 4 5 6 % source setup-SFU-CMPT-431.sh % mkdir -p ${ HOME } /SFU-CMPT-431 % cd ${ HOME } /SFU-CMPT-431 % git clone https://github.com/githubid/SFU-CMPT-431-tut3-c-basics.git tut3 % cd tut3 % TUTROOT = ${ PWD } Note It should be possible to experiment with this tutorial even if you are not enrolled in the course and/or do not have access to the course computing resources. All of the code for the tutorial is located on GitHub. You will not use the setup-SFU-CMPT-431.sh script, and your specific environment may be different from what is assumed in this tutorial.","title":"Tutorial 3 : Compiling and Running C Programs"},{"location":"SFU-CMPT-431-tut3-c-basics/#1-using-the-c-preprocessor","text":"Before we can understand how to write and compile C programs, we need to understand the C preprocessor. The preprocessor takes an input C source file, preprocesses it, and generates the preprocessed version of the C source file. It is important to realize that the C preprocesor is not really part of the C programming language. The C preprocessor simply manipulates the text in the C source files and knows nothing about the C programming language's syntax or semantics. The C preprocessor is powerful but also very easy to abuse. Using the C preprocessor can cause subtle bugs and is usually not necessary. Unfortunately, there are a few cases where we have no choice but to use the C preprocessor, so we must learn at least the basics. You can find out more about the C preprocessor here: http://en.cppreference.com/w/c/preprocessor https://en.wikibooks.org/wiki/C_Programming/Preprocessor","title":"1. Using the C Preprocessor"},{"location":"SFU-CMPT-431-tut3-c-basics/#11-the-define-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we are writing a report on the history of Cornell University, and we have a common snippet of text that we use often in our text file. text with many of same code define that mention ALL_CAPS define with argument try to avoid this -- will see it in our test macros","title":"1.1. The #define Directive"},{"location":"SFU-CMPT-431-tut3-c-basics/#12-the-ifdef-directive","text":"","title":"1.2. The #ifdef Directive"},{"location":"SFU-CMPT-431-tut3-c-basics/#13-the-include-directive","text":"The best way to understand the C preprocessor is actually to use it to preprocess standard text files as opposed to C source files. Assume we wish to create a text file which lists pioneering women and men in the field of computer science. We might start with a text file of pioneering women: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation and a separate text file of pioneering men: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer These two files require some duplication, since both files include a short introductory paragraph. To avoid this redundancy, we can first refactor this introductory paragraph into its own dedicated text file, and we can then use the C processor to include this file at the beginning of each list of pioneers. This new approach is illustrated below. First, we have a file named cs-pioneers-intro.txt with the introductory paragraph. 1 2 3 4 5 6 7 8 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. Then, we have a file named cs-pioneers-women-in.txt containing a list of pioneering women in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation Finally, we have a file named cs-pioneers-men-in.txt containing a list of pioneering men in computer science: 1 2 3 4 5 6 7 8 9 #include \"cs-pioneers-intro.txt\" - Donald Knuth : fundamental contributions to algorithm analysis - John Mauchly : designed and built first modern computer - J. Presper Eckert : designed and built first modern computer - John Von Neumann : formulated the von Neumann architecture - Maurice Wilkes : built first practical stored program computer - Alan Turing : invented Turning model, stored program concept - Charles Babbage : originated concept of programmable computer We can then use the C preprocessor to preprocess these files. The C preprocessor copies the input source file to the output source file, while also looking for C preprocessor directives . All C preprocessor directives begin with the special # character. Line 1 in cs-pioneers-women-in.txt and cs-pioneers-men-in.txt uses the #include directive which specifies the file name of a different text file to include. The file name should be be specified using double quotes ( \"\" ). You should have already cloned the tutorial repository and set the TUTROOT environment variable at the beginning of this tutorial. Let's make a new directory to work in for this section: 1 2 % mkdir ${ TUTROOT } /tut3-cpp % cd ${ TUTROOT } /tut3-cpp Now create the three text files mentioned above: cs-pioneers-intro.txt , cs-pioneers-women-in.txt , and cs-pioneers-men-in.txt using Geany or the text editor of your choice. See the first tutorial for more on using Geany or other text editors. The three files should be in the tut3-cpp subdirectory. All text files have a .txt filename extension. In general, we prefer using dashes ( - ) instead of underscores to separate words in file names. Let's use the C preprocessor ( cpp ) to preprocess the -in.txt files into two final text files that contain both the introductory paragraph and the list of pionners in computer science. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt The -o command line option is used to specify the name of the output file. The outpfile cs-pioneers-women.txt should look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 1 \"cs-pioneers-women-in.txt\" # 1 \"<built-in>\" # 1 \"<command-line>\" # 1 \"cs-pioneers-women-in.txt\" # 1 \"cs-pioneers-intro.txt\" 1 ========================================================================== Pioneers in Computer Science ========================================================================== Computer science is a relatively recent field which focuses on the theory, experimentation, and engineering that form the basis for the design and use of computers. Here is a very small subset of the many individuals who helped in the creation, development, and imagining of what computers and electronics could do. # 2 \"cs-pioneers-women-in.txt\" 2 - Eva Tardos : fundamental contributions to algorithm analysis - Mary Jane Irwin : early work on design automation and computer arch - Barbara Liskov : fundamental contributions to obj-oriented progr - Frances Allen : pioneer in optimizing compilers - Grace Hopper : pioneer in computer prog and high-level languages - Jean Bartik : one of the first computer programmers - Ada Lovelace : began the study of scientific computation The C preprocessor included the introductory paragraph correctly, but it has also included some additional lines beginning with the # character to specify information about where all of the pieces of text originally came from. For example, Line 5 indicates that the introductory paragraph came from the cs-pioneers-intro.txt file. We can tell the cpp to not include this extra metadata with the -P command line option. 1 2 3 4 5 % cd ${ TUTROOT } /tut3-cpp % cpp -P -o cs-pioneers-women.txt cs-pioneers-women-in.txt % cat cs-pioneers-women.txt % cpp -P -o cs-pioneers-men.txt cs-pioneers-men-in.txt % cat cs-pioneers-men.txt This example illustrates the first way we will use the C preprocessor. We will use the #include directive to include common C source files in several of our own C source files. This approach avoids redundancy and makes our programs much easier to maintain since we can make changes in a single C source file, and those changes can be immediately reflected in any program which includes that C source file. We have actually already seen this use of the C preprocessor in the previous section when we included the \\TT{stdio.h} header file which includes the declaration of the \\TT{printf} function (see Line~1 in Figure~\\ref{fig-tut3-code-avg-main}). If the file in an \\verb|#include| directive is specified using angle brackets (\\TT{<>}) then this tells the C preprocessor that the file to include is part of the system and is installed in a default location. If the given file is specified using double quotes (\\TT{\"\"}), then this tells the C preprocessor that the file to be included is part of the user program. The C preprocessor does not automatically know where to find extra user files, so we might need to add extra command line options to \\TT{cpp} to tell the C preprocessor where to search for files.","title":"1.3. The #include Directive"},{"location":"SFU-CMPT-431-tut3-c-basics/#14-include-guards","text":"","title":"1.4. Include Guards"},{"location":"SFU-CMPT-431-tut3-c-basics/#2-writing-a-single-file-c-program","text":"","title":"2. Writing a Single-File C Program"},{"location":"SFU-CMPT-431-tut3-c-basics/#3-compiling-a-single-file-c-program","text":"","title":"3. Compiling a Single-File C Program"},{"location":"SFU-CMPT-431-tut3-c-basics/#4-writing-a-multi-file-c-program","text":"","title":"4. Writing a Multi-File C Program"},{"location":"SFU-CMPT-431-tut3-c-basics/#5-compiling-a-multi-file-c-program","text":"","title":"5. Compiling a Multi-File C Program"}]}